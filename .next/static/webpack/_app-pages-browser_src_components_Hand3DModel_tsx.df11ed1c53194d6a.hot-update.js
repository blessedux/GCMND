"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Hand3DModel_tsx",{

/***/ "(app-pages-browser)/./src/components/Hand3DModel.tsx":
/*!****************************************!*\
  !*** ./src/components/Hand3DModel.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Hand3DModel; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Hand3DModel(param) {\n    let { leftHand, rightHand } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let handTexture;\n            p.preload = ()=>{\n                // Create a realistic hand texture programmatically\n                handTexture = p.createImage(128, 128);\n                handTexture.loadPixels();\n                for(let y = 0; y < handTexture.height; y++){\n                    for(let x = 0; x < handTexture.width; x++){\n                        const index = (y * handTexture.width + x) * 4;\n                        // Create skin-like color with variation\n                        const baseR = 255;\n                        const baseG = 200 + Math.sin(x * 0.1) * 20;\n                        const baseB = 150 + Math.cos(y * 0.1) * 15;\n                        // Add some texture variation\n                        const noise = Math.sin(x * 0.05) * Math.cos(y * 0.05) * 10;\n                        handTexture.pixels[index] = Math.max(200, Math.min(255, baseR + noise)); // R\n                        handTexture.pixels[index + 1] = Math.max(180, Math.min(220, baseG + noise)); // G\n                        handTexture.pixels[index + 2] = Math.max(140, Math.min(170, baseB + noise)); // B\n                        handTexture.pixels[index + 3] = 255; // A\n                    }\n                }\n                handTexture.updatePixels();\n            };\n            p.setup = ()=>{\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(60);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                // Set up lighting\n                p.ambientLight(60, 60, 60);\n                p.directionalLight(255, 255, 255, 0, 0, -1);\n                p.pointLight(255, 255, 255, 0, 0, 0);\n                // Render left hand\n                if (leftHand) {\n                    renderHand3D(p, leftHand.landmarks, [\n                        0,\n                        255,\n                        0\n                    ], \"left\");\n                }\n                // Render right hand\n                if (rightHand) {\n                    renderHand3D(p, rightHand.landmarks, [\n                        0,\n                        0,\n                        255\n                    ], \"right\");\n                }\n                p.pop();\n            };\n            const renderHand3D = (p, landmarks, color, handType)=>{\n                if (!landmarks || landmarks.length < 21) return;\n                p.push();\n                p.texture(handTexture);\n                p.noStroke();\n                // Calculate hand center and orientation\n                const handCenter = calculateHandCenter(landmarks);\n                const handRotation = calculateHandRotation(landmarks);\n                const handScale = calculateHandScale(landmarks);\n                // Transform to hand position\n                p.translate(-handCenter.x * p.width + p.width / 2, handCenter.y * p.height - p.height / 2, handCenter.z * 100);\n                p.rotateX(handRotation.x);\n                p.rotateY(handRotation.y);\n                p.rotateZ(handRotation.z);\n                p.scale(handScale);\n                // Render palm\n                renderPalm(p, landmarks, color);\n                // Render fingers\n                renderFingers(p, landmarks, color);\n                p.pop();\n            };\n            const calculateHandCenter = (landmarks)=>{\n                // Use wrist (landmark 0) as center\n                return {\n                    x: landmarks[0].x,\n                    y: landmarks[0].y,\n                    z: landmarks[0].z\n                };\n            };\n            const calculateHandRotation = (landmarks)=>{\n                // Calculate hand orientation based on palm landmarks\n                const wrist = landmarks[0];\n                const middleFinger = landmarks[12];\n                const indexFinger = landmarks[8];\n                // Calculate palm normal\n                const palmNormal = p.createVector(middleFinger.x - wrist.x, middleFinger.y - wrist.y, middleFinger.z - wrist.z);\n                return {\n                    x: Math.atan2(palmNormal.y, palmNormal.z),\n                    y: Math.atan2(palmNormal.x, palmNormal.z),\n                    z: Math.atan2(palmNormal.y, palmNormal.x)\n                };\n            };\n            const calculateHandScale = (landmarks)=>{\n                // Calculate hand size based on palm width\n                const wrist = landmarks[0];\n                const pinky = landmarks[17];\n                const thumb = landmarks[4];\n                const palmWidth = Math.abs(pinky.x - thumb.x);\n                return Math.max(0.5, Math.min(2.0, palmWidth * 10));\n            };\n            const renderPalm = (p, landmarks, color)=>{\n                // Create palm using spheres at key points\n                const palmLandmarks = [\n                    0,\n                    5,\n                    9,\n                    13,\n                    17\n                ]; // Wrist and finger bases\n                p.push();\n                p.fill(color[0], color[1], color[2], 150);\n                p.noStroke();\n                // Draw palm center\n                const wrist = landmarks[0];\n                const palmCenter = {\n                    x: (wrist.x - 0.5) * 2,\n                    y: (wrist.y - 0.5) * 2,\n                    z: wrist.z\n                };\n                p.push();\n                p.translate(palmCenter.x, palmCenter.y, palmCenter.z);\n                p.sphere(0.1);\n                p.pop();\n                // Draw palm connections\n                p.stroke(color[0], color[1], color[2], 100);\n                p.strokeWeight(3);\n                for(let i = 0; i < palmLandmarks.length - 1; i++){\n                    const current = landmarks[palmLandmarks[i]];\n                    const next = landmarks[palmLandmarks[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n            const renderFingers = (p, landmarks, color)=>{\n                // Finger landmark indices\n                const fingerIndices = [\n                    [\n                        4,\n                        3,\n                        2,\n                        1,\n                        0\n                    ],\n                    [\n                        8,\n                        7,\n                        6,\n                        5\n                    ],\n                    [\n                        12,\n                        11,\n                        10,\n                        9\n                    ],\n                    [\n                        16,\n                        15,\n                        14,\n                        13\n                    ],\n                    [\n                        20,\n                        19,\n                        18,\n                        17\n                    ] // Pinky\n                ];\n                fingerIndices.forEach((finger, fingerIndex)=>{\n                    renderFinger(p, landmarks, finger, color, fingerIndex);\n                });\n            };\n            const renderFinger = (p, landmarks, fingerIndices, color, fingerIndex)=>{\n                p.push();\n                p.fill(color[0], color[1], color[2], 200);\n                p.stroke(color[0], color[1], color[2], 100);\n                p.strokeWeight(2);\n                // Draw finger joints as spheres\n                for(let i = 0; i < fingerIndices.length; i++){\n                    const landmark = landmarks[fingerIndices[i]];\n                    const x = (landmark.x - 0.5) * 2;\n                    const y = (landmark.y - 0.5) * 2;\n                    const z = landmark.z;\n                    p.push();\n                    p.translate(x, y, z);\n                    const jointSize = 0.03 * (1 - i * 0.15); // Smaller towards tip\n                    p.sphere(jointSize);\n                    p.pop();\n                }\n                // Draw finger connections\n                p.noFill();\n                p.stroke(color[0], color[1], color[2], 150);\n                p.strokeWeight(2);\n                for(let i = 0; i < fingerIndices.length - 1; i++){\n                    const current = landmarks[fingerIndices[i]];\n                    const next = landmarks[fingerIndices[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        leftHand,\n        rightHand\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Hand3DModel.tsx\",\n        lineNumber: 259,\n        columnNumber: 10\n    }, this);\n}\n_s(Hand3DModel, \"J1m3QQsjy0l2HbZx7Pvyedp8RmE=\");\n_c = Hand3DModel;\nvar _c;\n$RefreshReg$(_c, \"Hand3DModel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hhbmQzRE1vZGVsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQztBQUN0QjtBQVFMLFNBQVNHLFlBQVksS0FBeUM7UUFBekMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQW9CLEdBQXpDOztJQUNsQyxNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUV4Q0QsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNNLFVBQVVFLE9BQU8sRUFBRTtRQUV4QixNQUFNQyxTQUFTLENBQUNDO1lBQ2QsSUFBSUM7WUFFSkQsRUFBRUUsT0FBTyxHQUFHO2dCQUNWLG1EQUFtRDtnQkFDbkRELGNBQWNELEVBQUVHLFdBQVcsQ0FBQyxLQUFLO2dCQUNqQ0YsWUFBWUcsVUFBVTtnQkFFdEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLFlBQVlLLE1BQU0sRUFBRUQsSUFBSztvQkFDM0MsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlOLFlBQVlPLEtBQUssRUFBRUQsSUFBSzt3QkFDMUMsTUFBTUUsUUFBUSxDQUFDSixJQUFJSixZQUFZTyxLQUFLLEdBQUdELENBQUFBLElBQUs7d0JBRTVDLHdDQUF3Qzt3QkFDeEMsTUFBTUcsUUFBUTt3QkFDZCxNQUFNQyxRQUFRLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ04sSUFBSSxPQUFPO3dCQUN4QyxNQUFNTyxRQUFRLE1BQU1GLEtBQUtHLEdBQUcsQ0FBQ1YsSUFBSSxPQUFPO3dCQUV4Qyw2QkFBNkI7d0JBQzdCLE1BQU1XLFFBQVFKLEtBQUtDLEdBQUcsQ0FBQ04sSUFBSSxRQUFRSyxLQUFLRyxHQUFHLENBQUNWLElBQUksUUFBUTt3QkFFeERKLFlBQVlnQixNQUFNLENBQUNSLE1BQU0sR0FBR0csS0FBS00sR0FBRyxDQUFDLEtBQUtOLEtBQUtPLEdBQUcsQ0FBQyxLQUFLVCxRQUFRTSxTQUFhLElBQUk7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QUcsR0FBRSxJQUFLO29CQUM1QixNQUFNb0UsS0FBSyxDQUFDTCxLQUFLakUsQ0FBQyxHQUFHLEdBQUUsSUFBSztvQkFDNUIsTUFBTXVFLEtBQUtOLEtBQUt4QixDQUFDO29CQUVqQjlDLEVBQUU2RSxJQUFJLENBQUNOLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO2dCQUM3QjtnQkFFQTVFLEVBQUVrQyxHQUFHO1lBQ1A7UUFDRjtRQUVBckMsY0FBY0MsT0FBTyxHQUFHLElBQUlOLDJDQUFFQSxDQUFDTyxRQUFRSCxVQUFVRSxPQUFPO1FBRXhELE9BQU87WUFDTCxJQUFJRCxjQUFjQyxPQUFPLEVBQUU7Z0JBQ3pCRCxjQUFjQyxPQUFPLENBQUN3RixNQUFNO2dCQUM1QnpGLGNBQWNDLE9BQU8sR0FBRztZQUMxQjtRQUNGO0lBQ0YsR0FBRztRQUFDSjtRQUFVQztLQUFVO0lBRXhCLHFCQUFPLDhEQUFDNEY7UUFBSUMsS0FBSzVGOzs7Ozs7QUFDbkI7R0F4UHdCSDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9IYW5kM0RNb2RlbC50c3g/MzhmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHA1IGZyb20gJ3A1JztcbmltcG9ydCB7IEhhbmREYXRhIH0gZnJvbSAnQC90eXBlcyc7XG5cbmludGVyZmFjZSBIYW5kM0RNb2RlbFByb3BzIHtcbiAgbGVmdEhhbmQ6IEhhbmREYXRhIHwgbnVsbDtcbiAgcmlnaHRIYW5kOiBIYW5kRGF0YSB8IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhhbmQzRE1vZGVsKHsgbGVmdEhhbmQsIHJpZ2h0SGFuZCB9OiBIYW5kM0RNb2RlbFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHA1SW5zdGFuY2VSZWYgPSB1c2VSZWY8cDUgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHNrZXRjaCA9IChwOiBwNSkgPT4ge1xuICAgICAgbGV0IGhhbmRUZXh0dXJlOiBwNS5JbWFnZTtcblxuICAgICAgcC5wcmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBDcmVhdGUgYSByZWFsaXN0aWMgaGFuZCB0ZXh0dXJlIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgICAgaGFuZFRleHR1cmUgPSBwLmNyZWF0ZUltYWdlKDEyOCwgMTI4KTtcbiAgICAgICAgaGFuZFRleHR1cmUubG9hZFBpeGVscygpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoYW5kVGV4dHVyZS5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaGFuZFRleHR1cmUud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoeSAqIGhhbmRUZXh0dXJlLndpZHRoICsgeCkgKiA0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgc2tpbi1saWtlIGNvbG9yIHdpdGggdmFyaWF0aW9uXG4gICAgICAgICAgICBjb25zdCBiYXNlUiA9IDI1NTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VHID0gMjAwICsgTWF0aC5zaW4oeCAqIDAuMSkgKiAyMDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VCID0gMTUwICsgTWF0aC5jb3MoeSAqIDAuMSkgKiAxNTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHNvbWUgdGV4dHVyZSB2YXJpYXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5vaXNlID0gTWF0aC5zaW4oeCAqIDAuMDUpICogTWF0aC5jb3MoeSAqIDAuMDUpICogMTA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGhhbmRUZXh0dXJlLnBpeGVsc1tpbmRleF0gPSBNYXRoLm1heCgyMDAsIE1hdGgubWluKDI1NSwgYmFzZVIgKyBub2lzZSkpOyAgICAgLy8gUlxuICAgICAgICAgICAgaGFuZFRleHR1cmUucGl4ZWxzW2luZGV4ICsgMV0gPSBNYXRoLm1heCgxODAsIE1hdGgubWluKDIyMCwgYmFzZUcgKyBub2lzZSkpOyAvLyBHXG4gICAgICAgICAgICBoYW5kVGV4dHVyZS5waXhlbHNbaW5kZXggKyAyXSA9IE1hdGgubWF4KDE0MCwgTWF0aC5taW4oMTcwLCBiYXNlQiArIG5vaXNlKSk7IC8vIEJcbiAgICAgICAgICAgIGhhbmRUZXh0dXJlLnBpeGVsc1tpbmRleCArIDNdID0gMjU1OyAvLyBBXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRUZXh0dXJlLnVwZGF0ZVBpeGVscygpO1xuICAgICAgfTtcblxuICAgICAgcC5zZXR1cCA9ICgpID0+IHtcbiAgICAgICAgcC5jcmVhdGVDYW52YXMoODAwLCA2NDAsIHAuV0VCR0wpO1xuICAgICAgICBwLmZyYW1lUmF0ZSg2MCk7XG4gICAgICB9O1xuXG4gICAgICBwLmRyYXcgPSAoKSA9PiB7XG4gICAgICAgIHAuY2xlYXIoKTtcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAudHJhbnNsYXRlKDAsIDAsIC0xMDApO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIGxpZ2h0aW5nXG4gICAgICAgIHAuYW1iaWVudExpZ2h0KDYwLCA2MCwgNjApO1xuICAgICAgICBwLmRpcmVjdGlvbmFsTGlnaHQoMjU1LCAyNTUsIDI1NSwgMCwgMCwgLTEpO1xuICAgICAgICBwLnBvaW50TGlnaHQoMjU1LCAyNTUsIDI1NSwgMCwgMCwgMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgbGVmdCBoYW5kXG4gICAgICAgIGlmIChsZWZ0SGFuZCkge1xuICAgICAgICAgIHJlbmRlckhhbmQzRChwLCBsZWZ0SGFuZC5sYW5kbWFya3MsIFswLCAyNTUsIDBdLCAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgcmlnaHQgaGFuZFxuICAgICAgICBpZiAocmlnaHRIYW5kKSB7XG4gICAgICAgICAgcmVuZGVySGFuZDNEKHAsIHJpZ2h0SGFuZC5sYW5kbWFya3MsIFswLCAwLCAyNTVdLCAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlckhhbmQzRCA9IChwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgY29sb3I6IG51bWJlcltdLCBoYW5kVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghbGFuZG1hcmtzIHx8IGxhbmRtYXJrcy5sZW5ndGggPCAyMSkgcmV0dXJuO1xuXG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRleHR1cmUoaGFuZFRleHR1cmUpO1xuICAgICAgICBwLm5vU3Ryb2tlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZCBjZW50ZXIgYW5kIG9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IGhhbmRDZW50ZXIgPSBjYWxjdWxhdGVIYW5kQ2VudGVyKGxhbmRtYXJrcyk7XG4gICAgICAgIGNvbnN0IGhhbmRSb3RhdGlvbiA9IGNhbGN1bGF0ZUhhbmRSb3RhdGlvbihsYW5kbWFya3MpO1xuICAgICAgICBjb25zdCBoYW5kU2NhbGUgPSBjYWxjdWxhdGVIYW5kU2NhbGUobGFuZG1hcmtzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyYW5zZm9ybSB0byBoYW5kIHBvc2l0aW9uXG4gICAgICAgIHAudHJhbnNsYXRlKFxuICAgICAgICAgIC1oYW5kQ2VudGVyLnggKiBwLndpZHRoICsgcC53aWR0aCAvIDIsXG4gICAgICAgICAgaGFuZENlbnRlci55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDIsXG4gICAgICAgICAgaGFuZENlbnRlci56ICogMTAwXG4gICAgICAgICk7XG4gICAgICAgIHAucm90YXRlWChoYW5kUm90YXRpb24ueCk7XG4gICAgICAgIHAucm90YXRlWShoYW5kUm90YXRpb24ueSk7XG4gICAgICAgIHAucm90YXRlWihoYW5kUm90YXRpb24ueik7XG4gICAgICAgIHAuc2NhbGUoaGFuZFNjYWxlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbmRlciBwYWxtXG4gICAgICAgIHJlbmRlclBhbG0ocCwgbGFuZG1hcmtzLCBjb2xvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgZmluZ2Vyc1xuICAgICAgICByZW5kZXJGaW5nZXJzKHAsIGxhbmRtYXJrcywgY29sb3IpO1xuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUhhbmRDZW50ZXIgPSAobGFuZG1hcmtzOiBhbnlbXSkgPT4ge1xuICAgICAgICAvLyBVc2Ugd3Jpc3QgKGxhbmRtYXJrIDApIGFzIGNlbnRlclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGxhbmRtYXJrc1swXS54LFxuICAgICAgICAgIHk6IGxhbmRtYXJrc1swXS55LFxuICAgICAgICAgIHo6IGxhbmRtYXJrc1swXS56XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjYWxjdWxhdGVIYW5kUm90YXRpb24gPSAobGFuZG1hcmtzOiBhbnlbXSkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZCBvcmllbnRhdGlvbiBiYXNlZCBvbiBwYWxtIGxhbmRtYXJrc1xuICAgICAgICBjb25zdCB3cmlzdCA9IGxhbmRtYXJrc1swXTtcbiAgICAgICAgY29uc3QgbWlkZGxlRmluZ2VyID0gbGFuZG1hcmtzWzEyXTtcbiAgICAgICAgY29uc3QgaW5kZXhGaW5nZXIgPSBsYW5kbWFya3NbOF07XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgcGFsbSBub3JtYWxcbiAgICAgICAgY29uc3QgcGFsbU5vcm1hbCA9IHAuY3JlYXRlVmVjdG9yKFxuICAgICAgICAgIG1pZGRsZUZpbmdlci54IC0gd3Jpc3QueCxcbiAgICAgICAgICBtaWRkbGVGaW5nZXIueSAtIHdyaXN0LnksXG4gICAgICAgICAgbWlkZGxlRmluZ2VyLnogLSB3cmlzdC56XG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGguYXRhbjIocGFsbU5vcm1hbC55LCBwYWxtTm9ybWFsLnopLFxuICAgICAgICAgIHk6IE1hdGguYXRhbjIocGFsbU5vcm1hbC54LCBwYWxtTm9ybWFsLnopLFxuICAgICAgICAgIHo6IE1hdGguYXRhbjIocGFsbU5vcm1hbC55LCBwYWxtTm9ybWFsLngpXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjYWxjdWxhdGVIYW5kU2NhbGUgPSAobGFuZG1hcmtzOiBhbnlbXSkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZCBzaXplIGJhc2VkIG9uIHBhbG0gd2lkdGhcbiAgICAgICAgY29uc3Qgd3Jpc3QgPSBsYW5kbWFya3NbMF07XG4gICAgICAgIGNvbnN0IHBpbmt5ID0gbGFuZG1hcmtzWzE3XTtcbiAgICAgICAgY29uc3QgdGh1bWIgPSBsYW5kbWFya3NbNF07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYWxtV2lkdGggPSBNYXRoLmFicyhwaW5reS54IC0gdGh1bWIueCk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLjUsIE1hdGgubWluKDIuMCwgcGFsbVdpZHRoICogMTApKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlclBhbG0gPSAocDogcDUsIGxhbmRtYXJrczogYW55W10sIGNvbG9yOiBudW1iZXJbXSkgPT4ge1xuICAgICAgICAvLyBDcmVhdGUgcGFsbSB1c2luZyBzcGhlcmVzIGF0IGtleSBwb2ludHNcbiAgICAgICAgY29uc3QgcGFsbUxhbmRtYXJrcyA9IFswLCA1LCA5LCAxMywgMTddOyAvLyBXcmlzdCBhbmQgZmluZ2VyIGJhc2VzXG4gICAgICAgIFxuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIDE1MCk7XG4gICAgICAgIHAubm9TdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcGFsbSBjZW50ZXJcbiAgICAgICAgY29uc3Qgd3Jpc3QgPSBsYW5kbWFya3NbMF07XG4gICAgICAgIGNvbnN0IHBhbG1DZW50ZXIgPSB7XG4gICAgICAgICAgeDogKHdyaXN0LnggLSAwLjUpICogMixcbiAgICAgICAgICB5OiAod3Jpc3QueSAtIDAuNSkgKiAyLFxuICAgICAgICAgIHo6IHdyaXN0LnpcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRyYW5zbGF0ZShwYWxtQ2VudGVyLngsIHBhbG1DZW50ZXIueSwgcGFsbUNlbnRlci56KTtcbiAgICAgICAgcC5zcGhlcmUoMC4xKTtcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcGFsbSBjb25uZWN0aW9uc1xuICAgICAgICBwLnN0cm9rZShjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCAxMDApO1xuICAgICAgICBwLnN0cm9rZVdlaWdodCgzKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFsbUxhbmRtYXJrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbGFuZG1hcmtzW3BhbG1MYW5kbWFya3NbaV1dO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBsYW5kbWFya3NbcGFsbUxhbmRtYXJrc1tpICsgMV1dO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgxID0gKGN1cnJlbnQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkxID0gKGN1cnJlbnQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoxID0gY3VycmVudC56O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgyID0gKG5leHQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkyID0gKG5leHQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoyID0gbmV4dC56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAubGluZSh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlckZpbmdlcnMgPSAocDogcDUsIGxhbmRtYXJrczogYW55W10sIGNvbG9yOiBudW1iZXJbXSkgPT4ge1xuICAgICAgICAvLyBGaW5nZXIgbGFuZG1hcmsgaW5kaWNlc1xuICAgICAgICBjb25zdCBmaW5nZXJJbmRpY2VzID0gW1xuICAgICAgICAgIFs0LCAzLCAyLCAxLCAwXSwgICAgLy8gVGh1bWJcbiAgICAgICAgICBbOCwgNywgNiwgNV0sICAgICAgIC8vIEluZGV4XG4gICAgICAgICAgWzEyLCAxMSwgMTAsIDldLCAgICAvLyBNaWRkbGVcbiAgICAgICAgICBbMTYsIDE1LCAxNCwgMTNdLCAgIC8vIFJpbmdcbiAgICAgICAgICBbMjAsIDE5LCAxOCwgMTddICAgIC8vIFBpbmt5XG4gICAgICAgIF07XG5cbiAgICAgICAgZmluZ2VySW5kaWNlcy5mb3JFYWNoKChmaW5nZXIsIGZpbmdlckluZGV4KSA9PiB7XG4gICAgICAgICAgcmVuZGVyRmluZ2VyKHAsIGxhbmRtYXJrcywgZmluZ2VyLCBjb2xvciwgZmluZ2VySW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlckZpbmdlciA9IChwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgZmluZ2VySW5kaWNlczogbnVtYmVyW10sIGNvbG9yOiBudW1iZXJbXSwgZmluZ2VySW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIDIwMCk7XG4gICAgICAgIHAuc3Ryb2tlKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIDEwMCk7XG4gICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBmaW5nZXIgam9pbnRzIGFzIHNwaGVyZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5nZXJJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYW5kbWFya3NbZmluZ2VySW5kaWNlc1tpXV07XG4gICAgICAgICAgY29uc3QgeCA9IChsYW5kbWFyay54IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeSA9IChsYW5kbWFyay55IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgXG4gICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgcC50cmFuc2xhdGUoeCwgeSwgeik7XG4gICAgICAgICAgY29uc3Qgam9pbnRTaXplID0gMC4wMyAqICgxIC0gaSAqIDAuMTUpOyAvLyBTbWFsbGVyIHRvd2FyZHMgdGlwXG4gICAgICAgICAgcC5zcGhlcmUoam9pbnRTaXplKTtcbiAgICAgICAgICBwLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IGZpbmdlciBjb25uZWN0aW9uc1xuICAgICAgICBwLm5vRmlsbCgpO1xuICAgICAgICBwLnN0cm9rZShjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCAxNTApO1xuICAgICAgICBwLnN0cm9rZVdlaWdodCgyKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluZ2VySW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbGFuZG1hcmtzW2ZpbmdlckluZGljZXNbaV1dO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBsYW5kbWFya3NbZmluZ2VySW5kaWNlc1tpICsgMV1dO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgxID0gKGN1cnJlbnQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkxID0gKGN1cnJlbnQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoxID0gY3VycmVudC56O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgyID0gKG5leHQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkyID0gKG5leHQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoyID0gbmV4dC56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAubGluZSh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyBwNShza2V0Y2gsIGNhbnZhc1JlZi5jdXJyZW50KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocDVJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbGVmdEhhbmQsIHJpZ2h0SGFuZF0pO1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y2FudmFzUmVmfSAvPjtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInA1IiwiSGFuZDNETW9kZWwiLCJsZWZ0SGFuZCIsInJpZ2h0SGFuZCIsImNhbnZhc1JlZiIsInA1SW5zdGFuY2VSZWYiLCJjdXJyZW50Iiwic2tldGNoIiwicCIsImhhbmRUZXh0dXJlIiwicHJlbG9hZCIsImNyZWF0ZUltYWdlIiwibG9hZFBpeGVscyIsInkiLCJoZWlnaHQiLCJ4Iiwid2lkdGgiLCJpbmRleCIsImJhc2VSIiwiYmFzZUciLCJNYXRoIiwic2luIiwiYmFzZUIiLCJjb3MiLCJub2lzZSIsInBpeGVscyIsIm1heCIsIm1pbiIsInVwZGF0ZVBpeGVscyIsInNldHVwIiwiY3JlYXRlQ2FudmFzIiwiV0VCR0wiLCJmcmFtZVJhdGUiLCJkcmF3IiwiY2xlYXIiLCJwdXNoIiwidHJhbnNsYXRlIiwiYW1iaWVudExpZ2h0IiwiZGlyZWN0aW9uYWxMaWdodCIsInBvaW50TGlnaHQiLCJyZW5kZXJIYW5kM0QiLCJsYW5kbWFya3MiLCJwb3AiLCJjb2xvciIsImhhbmRUeXBlIiwibGVuZ3RoIiwidGV4dHVyZSIsIm5vU3Ryb2tlIiwiaGFuZENlbnRlciIsImNhbGN1bGF0ZUhhbmRDZW50ZXIiLCJoYW5kUm90YXRpb24iLCJjYWxjdWxhdGVIYW5kUm90YXRpb24iLCJoYW5kU2NhbGUiLCJjYWxjdWxhdGVIYW5kU2NhbGUiLCJ6Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2NhbGUiLCJyZW5kZXJQYWxtIiwicmVuZGVyRmluZ2VycyIsIndyaXN0IiwibWlkZGxlRmluZ2VyIiwiaW5kZXhGaW5nZXIiLCJwYWxtTm9ybWFsIiwiY3JlYXRlVmVjdG9yIiwiYXRhbjIiLCJwaW5reSIsInRodW1iIiwicGFsbVdpZHRoIiwiYWJzIiwicGFsbUxhbmRtYXJrcyIsImZpbGwiLCJwYWxtQ2VudGVyIiwic3BoZXJlIiwic3Ryb2tlIiwic3Ryb2tlV2VpZ2h0IiwiaSIsIm5leHQiLCJ4MSIsInkxIiwiejEiLCJ4MiIsInkyIiwiejIiLCJsaW5lIiwiZmluZ2VySW5kaWNlcyIsImZvckVhY2giLCJmaW5nZXIiLCJmaW5nZXJJbmRleCIsInJlbmRlckZpbmdlciIsImxhbmRtYXJrIiwiam9pbnRTaXplIiwibm9GaWxsIiwicmVtb3ZlIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Hand3DModel.tsx\n"));

/***/ })

});
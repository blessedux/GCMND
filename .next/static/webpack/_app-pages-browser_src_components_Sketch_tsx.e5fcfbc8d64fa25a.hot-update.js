"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Sketch_tsx",{

/***/ "(app-pages-browser)/./src/components/Sketch.tsx":
/*!***********************************!*\
  !*** ./src/components/Sketch.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sketch; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Sketch(param) {\n    let { multiHandData, videoRef } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const smoothedLandmarksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHand: null,\n        rightHand: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let objectVector;\n            let objectSize = 1;\n            let lastObjectSize = 1;\n            let objectSizeSmooth = 0;\n            let grabbing = false;\n            let locked = false;\n            p.setup = ()=>{\n                objectVector = p.createVector(100, 0, 0);\n                p.createCanvas(800, 640, p.WEBGL);\n                // Use system font instead of loading custom font\n                try {\n                    p.textFont('system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif');\n                } catch (error) {\n                    console.warn(\"Font loading failed, using default:\", error);\n                    // Fallback to default font\n                    p.textFont(\"Arial\");\n                }\n                p.textSize(12);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                p.pop();\n                // Enhanced gesture display\n                p.strokeWeight(5);\n                // Color based on gesture type (using primary hand)\n                let gestureColor;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                if (primaryHand) {\n                    switch(primaryHand.gesture){\n                        case \"pinch\":\n                            gestureColor = p.color(255, 0, 0); // Red\n                            break;\n                        case \"fist\":\n                            gestureColor = p.color(255, 165, 0); // Orange\n                            break;\n                        case \"openHand\":\n                            gestureColor = p.color(0, 255, 0); // Green\n                            break;\n                        case \"pointing\":\n                            gestureColor = p.color(0, 255, 255); // Cyan\n                            break;\n                        case \"victory\":\n                            gestureColor = p.color(255, 0, 255); // Magenta\n                            break;\n                        default:\n                            gestureColor = p.color(128, 128, 128); // Gray\n                    }\n                } else {\n                    gestureColor = p.color(128, 128, 128); // Gray\n                }\n                p.stroke(gestureColor);\n                // Draw gesture indicator line\n                const lineLength = primaryHand ? primaryHand.confidence * 300 : 0;\n                p.line(0, 0, lineLength, 0);\n                // Draw object which is being dragged\n                p.push();\n                p.fill(0, 0, 255, 100);\n                p.stroke(0, 0, 255);\n                p.translate(objectVector.x, objectVector.y, objectVector.z);\n                p.ellipse(0, 0, 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth), 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth));\n                p.pop();\n                // Draw landmarks\n                displayResults(p);\n                // Enhanced gesture-based interaction\n                if ((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) === \"pinch\") {\n                    grabbing = true;\n                } else {\n                    grabbing = false;\n                }\n                // Handle grabbing interaction with the object\n                if (grabbing && primaryHand) {\n                    // Use thumb tip (4) and index tip (8) for pinch position\n                    const thumbTip = primaryHand.landmarks[4];\n                    const indexTip = primaryHand.landmarks[8];\n                    // Calculate pinch center position\n                    const pinchX = (thumbTip.x + indexTip.x) / 2;\n                    const pinchY = (thumbTip.y + indexTip.y) / 2;\n                    const pinchZ = (thumbTip.z + indexTip.z) / 2;\n                    // Map to world coordinates\n                    let pinchVector = p.createVector(pinchX * p.width - p.width / 2, pinchY * p.height - p.height / 2, pinchZ);\n                    if (p.dist(pinchVector.x, pinchVector.y, objectVector.x, objectVector.y) < 50 && locked == false) {\n                        locked = true;\n                        objectSize = 2;\n                    }\n                    if (locked) {\n                        objectVector.x = pinchVector.x;\n                        objectVector.y = pinchVector.y;\n                        objectVector.z = pinchVector.z;\n                    }\n                } else {\n                    locked = false;\n                    objectSize = 1;\n                }\n                // Smooth object size\n                objectSizeSmooth = objectSize * 0.5 + lastObjectSize * 0.5;\n                lastObjectSize = objectSizeSmooth;\n                // Draw privacy indicator only\n                drawPrivacyIndicator(p);\n            };\n            function displayResults(p) {\n                // Draw left hand landmarks (green)\n                if (multiHandData.leftHand) {\n                    p.stroke(0, 255, 0); // Green for left hand\n                    p.strokeWeight(3);\n                    for(let i = 0; i < multiHandData.leftHand.landmarks.length; i++){\n                        const landmark = multiHandData.leftHand.landmarks[i];\n                        p.point(landmark.x * p.width - p.width / 2, landmark.y * p.height - p.height / 2, landmark.z);\n                    }\n                }\n                // Draw right hand landmarks (blue)\n                if (multiHandData.rightHand) {\n                    p.stroke(0, 0, 255); // Blue for right hand\n                    p.strokeWeight(3);\n                    for(let i = 0; i < multiHandData.rightHand.landmarks.length; i++){\n                        const landmark = multiHandData.rightHand.landmarks[i];\n                        p.point(landmark.x * p.width - p.width / 2, landmark.y * p.height - p.height / 2, landmark.z);\n                    }\n                }\n            }\n            function drawGestureDebug(p) {\n                p.push();\n                p.fill(255);\n                p.textAlign(p.LEFT);\n                p.textSize(14);\n                let yPos = -p.height / 2 + 20;\n                p.text(\"Multi-Hand Gesture Debug:\", -p.width / 2 + 10, yPos);\n                yPos += 20;\n                // Left hand info\n                if (multiHandData.leftHand) {\n                    p.text(\"Left Hand: \".concat(multiHandData.leftHand.gesture, \" (\").concat(Math.round(multiHandData.leftHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Left Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Right hand info\n                if (multiHandData.rightHand) {\n                    p.text(\"Right Hand: \".concat(multiHandData.rightHand.gesture, \" (\").concat(Math.round(multiHandData.rightHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Right Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Combined info\n                yPos += 10;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                p.text(\"Primary: \".concat((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) || \"None\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Confidence: \".concat(Math.round(((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.confidence) || 0) * 100), \"%\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Hands Detected: \".concat(multiHandData.totalHands), -p.width / 2 + 10, yPos);\n                p.pop();\n            }\n            function drawPrivacyIndicator(p) {\n                p.push();\n                p.fill(0, 255, 0, 150);\n                p.textAlign(p.RIGHT);\n                p.textSize(12);\n                // Draw privacy indicator in top-right corner\n                p.text(\"Privacy Mode: Hand Tracking Only\", p.width / 2 - 10, -p.height / 2 + 20);\n                p.pop();\n            }\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        multiHandData\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Sketch.tsx\",\n        lineNumber: 247,\n        columnNumber: 10\n    }, this);\n}\n_s(Sketch, \"Zh72f/q+2It/yvCtgIksDCz/hSQ=\");\n_c = Sketch;\nvar _c;\n$RefreshReg$(_c, \"Sketch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFMEM7QUFDdEI7QUFRTCxTQUFTRyxPQUFPLEtBQXdDO1FBQXhDLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFlLEdBQXhDOztJQUM3QixNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUN4QyxNQUFNTyx1QkFBdUJQLDZDQUFNQSxDQUdoQztRQUFFUSxVQUFVO1FBQU1DLFdBQVc7SUFBSztJQUVyQ1YsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNNLFVBQVVLLE9BQU8sRUFBRTtRQUV4QixNQUFNQyxTQUFTLENBQUNDO1lBQ2QsSUFBSUM7WUFDSixJQUFJQyxhQUFhO1lBQ2pCLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyxtQkFBbUI7WUFDdkIsSUFBSUMsV0FBVztZQUNmLElBQUlDLFNBQVM7WUFFYk4sRUFBRU8sS0FBSyxHQUFHO2dCQUNSTixlQUFlRCxFQUFFUSxZQUFZLENBQUMsS0FBSyxHQUFHO2dCQUN0Q1IsRUFBRVMsWUFBWSxDQUFDLEtBQUssS0FBS1QsRUFBRVUsS0FBSztnQkFDaEMsaURBQWlEO2dCQUNqRCxJQUFJO29CQUNGVixFQUFFVyxRQUFRLENBQUM7Z0JBQ2IsRUFBRSxPQUFPQyxPQUFPO29CQUNkQyxRQUFRQyxJQUFJLENBQUMsdUNBQXVDRjtvQkFDcEQsMkJBQTJCO29CQUMzQlosRUFBRVcsUUFBUSxDQUFDO2dCQUNiO2dCQUNBWCxFQUFFZSxRQUFRLENBQUM7WUFDYjtZQUVBZixFQUFFZ0IsSUFBSSxHQUFHO2dCQUNQaEIsRUFBRWlCLEtBQUs7Z0JBQ1BqQixFQUFFa0IsSUFBSTtnQkFDTmxCLEVBQUVtQixTQUFTLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ25CbkIsRUFBRW9CLEdBQUc7Z0JBRUwsMkJBQTJCO2dCQUMzQnBCLEVBQUVxQixZQUFZ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QUFLLEdBQUc7Z0JBQ2xCOUIsRUFBRXFELFNBQVMsQ0FBQ3JELEVBQUU0RCxLQUFLO2dCQUNuQjVELEVBQUVlLFFBQVEsQ0FBQztnQkFFWCw2Q0FBNkM7Z0JBQzdDZixFQUFFd0QsSUFBSSxDQUFDLG9DQUFvQ3hELEVBQUU0QyxLQUFLLEdBQUMsSUFBSSxJQUFJLENBQUM1QyxFQUFFNkMsTUFBTSxHQUFDLElBQUk7Z0JBRXpFN0MsRUFBRW9CLEdBQUc7WUFDUDtRQUNGO1FBRUExQixjQUFjSSxPQUFPLEdBQUcsSUFBSVQsMkNBQUVBLENBQUNVLFFBQVFOLFVBQVVLLE9BQU87UUFFeEQsT0FBTztZQUNMLElBQUlKLGNBQWNJLE9BQU8sRUFBRTtnQkFDekJKLGNBQWNJLE9BQU8sQ0FBQytELE1BQU07Z0JBQzVCbkUsY0FBY0ksT0FBTyxHQUFHO1lBQzFCO1FBQ0Y7SUFDRixHQUFHO1FBQUNQO0tBQWM7SUFFbEIscUJBQU8sOERBQUN1RTtRQUFJQyxLQUFLdEU7Ozs7OztBQUNuQjtHQTVPd0JIO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3g/Mzc0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHA1IGZyb20gJ3A1JztcbmltcG9ydCB7IE11bHRpSGFuZERhdGEgfSBmcm9tICdAL3R5cGVzJztcblxuaW50ZXJmYWNlIFNrZXRjaFByb3BzIHtcbiAgbXVsdGlIYW5kRGF0YTogTXVsdGlIYW5kRGF0YTtcbiAgdmlkZW9SZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MVmlkZW9FbGVtZW50Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2tldGNoKHsgbXVsdGlIYW5kRGF0YSwgdmlkZW9SZWYgfTogU2tldGNoUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgcDVJbnN0YW5jZVJlZiA9IHVzZVJlZjxwNSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzbW9vdGhlZExhbmRtYXJrc1JlZiA9IHVzZVJlZjx7XG4gICAgbGVmdEhhbmQ6IGFueVtdIHwgbnVsbDtcbiAgICByaWdodEhhbmQ6IGFueVtdIHwgbnVsbDtcbiAgfT4oeyBsZWZ0SGFuZDogbnVsbCwgcmlnaHRIYW5kOiBudWxsIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2tldGNoID0gKHA6IHA1KSA9PiB7XG4gICAgICBsZXQgb2JqZWN0VmVjdG9yOiBwNS5WZWN0b3I7XG4gICAgICBsZXQgb2JqZWN0U2l6ZSA9IDE7XG4gICAgICBsZXQgbGFzdE9iamVjdFNpemUgPSAxO1xuICAgICAgbGV0IG9iamVjdFNpemVTbW9vdGggPSAwO1xuICAgICAgbGV0IGdyYWJiaW5nID0gZmFsc2U7XG4gICAgICBsZXQgbG9ja2VkID0gZmFsc2U7XG5cbiAgICAgIHAuc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIG9iamVjdFZlY3RvciA9IHAuY3JlYXRlVmVjdG9yKDEwMCwgMCwgMCk7XG4gICAgICAgIHAuY3JlYXRlQ2FudmFzKDgwMCwgNjQwLCBwLldFQkdMKTtcbiAgICAgICAgLy8gVXNlIHN5c3RlbSBmb250IGluc3RlYWQgb2YgbG9hZGluZyBjdXN0b20gZm9udFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHAudGV4dEZvbnQoJ3N5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgc2Fucy1zZXJpZicpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRm9udCBsb2FkaW5nIGZhaWxlZCwgdXNpbmcgZGVmYXVsdDonLCBlcnJvcik7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBmb250XG4gICAgICAgICAgcC50ZXh0Rm9udCgnQXJpYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBwLnRleHRTaXplKDEyKTtcbiAgICAgIH07XG5cbiAgICAgIHAuZHJhdyA9ICgpID0+IHtcbiAgICAgICAgcC5jbGVhcigpO1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC50cmFuc2xhdGUoMCwgMCwgLTEwMCk7XG4gICAgICAgIHAucG9wKCk7XG5cbiAgICAgICAgLy8gRW5oYW5jZWQgZ2VzdHVyZSBkaXNwbGF5XG4gICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29sb3IgYmFzZWQgb24gZ2VzdHVyZSB0eXBlICh1c2luZyBwcmltYXJ5IGhhbmQpXG4gICAgICAgIGxldCBnZXN0dXJlQ29sb3I7XG4gICAgICAgIGNvbnN0IHByaW1hcnlIYW5kID0gbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZCB8fCBtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcmltYXJ5SGFuZCkge1xuICAgICAgICAgIHN3aXRjaChwcmltYXJ5SGFuZC5nZXN0dXJlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGluY2hcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigyNTUsIDAsIDApOyAvLyBSZWRcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlzdFwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDI1NSwgMTY1LCAwKTsgLy8gT3JhbmdlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wZW5IYW5kXCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMCwgMjU1LCAwKTsgLy8gR3JlZW5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicG9pbnRpbmdcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigwLCAyNTUsIDI1NSk7IC8vIEN5YW5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmljdG9yeVwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDI1NSwgMCwgMjU1KTsgLy8gTWFnZW50YVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMTI4LCAxMjgsIDEyOCk7IC8vIEdyYXlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigxMjgsIDEyOCwgMTI4KTsgLy8gR3JheVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwLnN0cm9rZShnZXN0dXJlQ29sb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBnZXN0dXJlIGluZGljYXRvciBsaW5lXG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBwcmltYXJ5SGFuZCA/IHByaW1hcnlIYW5kLmNvbmZpZGVuY2UgKiAzMDAgOiAwO1xuICAgICAgICBwLmxpbmUoMCwgMCwgbGluZUxlbmd0aCwgMCk7XG5cbiAgICAgICAgLy8gRHJhdyBvYmplY3Qgd2hpY2ggaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKDAsIDAsIDI1NSwgMTAwKTtcbiAgICAgICAgcC5zdHJva2UoMCwgMCwgMjU1KTtcbiAgICAgICAgcC50cmFuc2xhdGUob2JqZWN0VmVjdG9yLngsIG9iamVjdFZlY3Rvci55LCBvYmplY3RWZWN0b3Iueik7XG4gICAgICAgIHAuZWxsaXBzZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMTAwICogcC5tYXAob2JqZWN0VmVjdG9yLnosIDAuMSwgLTAuMSwgMC4xLCBvYmplY3RTaXplU21vb3RoKSxcbiAgICAgICAgICAxMDAgKiBwLm1hcChvYmplY3RWZWN0b3IueiwgMC4xLCAtMC4xLCAwLjEsIG9iamVjdFNpemVTbW9vdGgpXG4gICAgICAgICk7XG4gICAgICAgIHAucG9wKCk7XG5cbiAgICAgICAgLy8gRHJhdyBsYW5kbWFya3NcbiAgICAgICAgZGlzcGxheVJlc3VsdHMocCk7XG5cbiAgICAgICAgLy8gRW5oYW5jZWQgZ2VzdHVyZS1iYXNlZCBpbnRlcmFjdGlvblxuICAgICAgICBpZiAocHJpbWFyeUhhbmQ/Lmdlc3R1cmUgPT09IFwicGluY2hcIikge1xuICAgICAgICAgIGdyYWJiaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFiYmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGdyYWJiaW5nIGludGVyYWN0aW9uIHdpdGggdGhlIG9iamVjdFxuICAgICAgICBpZiAoZ3JhYmJpbmcgJiYgcHJpbWFyeUhhbmQpIHtcbiAgICAgICAgICAvLyBVc2UgdGh1bWIgdGlwICg0KSBhbmQgaW5kZXggdGlwICg4KSBmb3IgcGluY2ggcG9zaXRpb25cbiAgICAgICAgICBjb25zdCB0aHVtYlRpcCA9IHByaW1hcnlIYW5kLmxhbmRtYXJrc1s0XTtcbiAgICAgICAgICBjb25zdCBpbmRleFRpcCA9IHByaW1hcnlIYW5kLmxhbmRtYXJrc1s4XTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcGluY2ggY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgY29uc3QgcGluY2hYID0gKHRodW1iVGlwLnggKyBpbmRleFRpcC54KSAvIDI7XG4gICAgICAgICAgY29uc3QgcGluY2hZID0gKHRodW1iVGlwLnkgKyBpbmRleFRpcC55KSAvIDI7XG4gICAgICAgICAgY29uc3QgcGluY2haID0gKHRodW1iVGlwLnogKyBpbmRleFRpcC56KSAvIDI7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFwIHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgbGV0IHBpbmNoVmVjdG9yID0gcC5jcmVhdGVWZWN0b3IoXG4gICAgICAgICAgICBwaW5jaFggKiBwLndpZHRoIC0gcC53aWR0aCAvIDIsXG4gICAgICAgICAgICBwaW5jaFkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHBpbmNoWlxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcC5kaXN0KHBpbmNoVmVjdG9yLngsIHBpbmNoVmVjdG9yLnksIG9iamVjdFZlY3Rvci54LCBvYmplY3RWZWN0b3IueSkgPCA1MCAmJlxuICAgICAgICAgICAgbG9ja2VkID09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgb2JqZWN0U2l6ZSA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci54ID0gcGluY2hWZWN0b3IueDtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci55ID0gcGluY2hWZWN0b3IueTtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci56ID0gcGluY2hWZWN0b3IuejtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgb2JqZWN0U2l6ZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbW9vdGggb2JqZWN0IHNpemVcbiAgICAgICAgb2JqZWN0U2l6ZVNtb290aCA9IG9iamVjdFNpemUgKiAwLjUgKyBsYXN0T2JqZWN0U2l6ZSAqIDAuNTtcbiAgICAgICAgbGFzdE9iamVjdFNpemUgPSBvYmplY3RTaXplU21vb3RoO1xuXG4gICAgICAgIC8vIERyYXcgcHJpdmFjeSBpbmRpY2F0b3Igb25seVxuICAgICAgICBkcmF3UHJpdmFjeUluZGljYXRvcihwKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGRpc3BsYXlSZXN1bHRzKHA6IHA1KSB7XG4gICAgICAgIC8vIERyYXcgbGVmdCBoYW5kIGxhbmRtYXJrcyAoZ3JlZW4pXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLmxlZnRIYW5kKSB7XG4gICAgICAgICAgcC5zdHJva2UoMCwgMjU1LCAwKTsgLy8gR3JlZW4gZm9yIGxlZnQgaGFuZFxuICAgICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDMpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5sYW5kbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5sYW5kbWFya3NbaV07XG4gICAgICAgICAgICBwLnBvaW50KFxuICAgICAgICAgICAgICBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyLFxuICAgICAgICAgICAgICBsYW5kbWFyay55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgIGxhbmRtYXJrLnpcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHJpZ2h0IGhhbmQgbGFuZG1hcmtzIChibHVlKVxuICAgICAgICBpZiAobXVsdGlIYW5kRGF0YS5yaWdodEhhbmQpIHtcbiAgICAgICAgICBwLnN0cm9rZSgwLCAwLCAyNTUpOyAvLyBCbHVlIGZvciByaWdodCBoYW5kXG4gICAgICAgICAgcC5zdHJva2VXZWlnaHQoMyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZC5sYW5kbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gbXVsdGlIYW5kRGF0YS5yaWdodEhhbmQubGFuZG1hcmtzW2ldO1xuICAgICAgICAgICAgcC5wb2ludChcbiAgICAgICAgICAgICAgbGFuZG1hcmsueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgbGFuZG1hcmsueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgICBsYW5kbWFyay56XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3R2VzdHVyZURlYnVnKHA6IHA1KSB7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLmZpbGwoMjU1KTtcbiAgICAgICAgcC50ZXh0QWxpZ24ocC5MRUZUKTtcbiAgICAgICAgcC50ZXh0U2l6ZSgxNCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgeVBvcyA9IC1wLmhlaWdodC8yICsgMjA7XG4gICAgICAgIHAudGV4dChcIk11bHRpLUhhbmQgR2VzdHVyZSBEZWJ1ZzpcIiwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAyMDtcbiAgICAgICAgXG4gICAgICAgIC8vIExlZnQgaGFuZCBpbmZvXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLmxlZnRIYW5kKSB7XG4gICAgICAgICAgcC50ZXh0KGBMZWZ0IEhhbmQ6ICR7bXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5nZXN0dXJlfSAoJHtNYXRoLnJvdW5kKG11bHRpSGFuZERhdGEubGVmdEhhbmQuY29uZmlkZW5jZSAqIDEwMCl9JSlgLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50ZXh0KFwiTGVmdCBIYW5kOiBOb3QgZGV0ZWN0ZWRcIiwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodCBoYW5kIGluZm9cbiAgICAgICAgaWYgKG11bHRpSGFuZERhdGEucmlnaHRIYW5kKSB7XG4gICAgICAgICAgcC50ZXh0KGBSaWdodCBIYW5kOiAke211bHRpSGFuZERhdGEucmlnaHRIYW5kLmdlc3R1cmV9ICgke01hdGgucm91bmQobXVsdGlIYW5kRGF0YS5yaWdodEhhbmQuY29uZmlkZW5jZSAqIDEwMCl9JSlgLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50ZXh0KFwiUmlnaHQgSGFuZDogTm90IGRldGVjdGVkXCIsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29tYmluZWQgaW5mb1xuICAgICAgICB5UG9zICs9IDEwO1xuICAgICAgICBjb25zdCBwcmltYXJ5SGFuZCA9IG11bHRpSGFuZERhdGEubGVmdEhhbmQgfHwgbXVsdGlIYW5kRGF0YS5yaWdodEhhbmQ7XG4gICAgICAgIHAudGV4dChgUHJpbWFyeTogJHtwcmltYXJ5SGFuZD8uZ2VzdHVyZSB8fCAnTm9uZSd9YCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgcC50ZXh0KGBDb25maWRlbmNlOiAke01hdGgucm91bmQoKHByaW1hcnlIYW5kPy5jb25maWRlbmNlIHx8IDApICogMTAwKX0lYCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgcC50ZXh0KGBIYW5kcyBEZXRlY3RlZDogJHttdWx0aUhhbmREYXRhLnRvdGFsSGFuZHN9YCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdQcml2YWN5SW5kaWNhdG9yKHA6IHA1KSB7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLmZpbGwoMCwgMjU1LCAwLCAxNTApO1xuICAgICAgICBwLnRleHRBbGlnbihwLlJJR0hUKTtcbiAgICAgICAgcC50ZXh0U2l6ZSgxMik7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHByaXZhY3kgaW5kaWNhdG9yIGluIHRvcC1yaWdodCBjb3JuZXJcbiAgICAgICAgcC50ZXh0KFwiUHJpdmFjeSBNb2RlOiBIYW5kIFRyYWNraW5nIE9ubHlcIiwgcC53aWR0aC8yIC0gMTAsIC1wLmhlaWdodC8yICsgMjApO1xuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50ID0gbmV3IHA1KHNrZXRjaCwgY2FudmFzUmVmLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwNUluc3RhbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFttdWx0aUhhbmREYXRhXSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjYW52YXNSZWZ9IC8+O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwicDUiLCJTa2V0Y2giLCJtdWx0aUhhbmREYXRhIiwidmlkZW9SZWYiLCJjYW52YXNSZWYiLCJwNUluc3RhbmNlUmVmIiwic21vb3RoZWRMYW5kbWFya3NSZWYiLCJsZWZ0SGFuZCIsInJpZ2h0SGFuZCIsImN1cnJlbnQiLCJza2V0Y2giLCJwIiwib2JqZWN0VmVjdG9yIiwib2JqZWN0U2l6ZSIsImxhc3RPYmplY3RTaXplIiwib2JqZWN0U2l6ZVNtb290aCIsImdyYWJiaW5nIiwibG9ja2VkIiwic2V0dXAiLCJjcmVhdGVWZWN0b3IiLCJjcmVhdGVDYW52YXMiLCJXRUJHTCIsInRleHRGb250IiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsInRleHRTaXplIiwiZHJhdyIsImNsZWFyIiwicHVzaCIsInRyYW5zbGF0ZSIsInBvcCIsInN0cm9rZVdlaWdodCIsImdlc3R1cmVDb2xvciIsInByaW1hcnlIYW5kIiwiZ2VzdHVyZSIsImNvbG9yIiwic3Ryb2tlIiwibGluZUxlbmd0aCIsImNvbmZpZGVuY2UiLCJsaW5lIiwiZmlsbCIsIngiLCJ5IiwieiIsImVsbGlwc2UiLCJtYXAiLCJkaXNwbGF5UmVzdWx0cyIsInRodW1iVGlwIiwibGFuZG1hcmtzIiwiaW5kZXhUaXAiLCJwaW5jaFgiLCJwaW5jaFkiLCJwaW5jaFoiLCJwaW5jaFZlY3RvciIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzdCIsImRyYXdQcml2YWN5SW5kaWNhdG9yIiwiaSIsImxlbmd0aCIsImxhbmRtYXJrIiwicG9pbnQiLCJkcmF3R2VzdHVyZURlYnVnIiwidGV4dEFsaWduIiwiTEVGVCIsInlQb3MiLCJ0ZXh0IiwiTWF0aCIsInJvdW5kIiwidG90YWxIYW5kcyIsIlJJR0hUIiwicmVtb3ZlIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Sketch.tsx\n"));

/***/ })

});
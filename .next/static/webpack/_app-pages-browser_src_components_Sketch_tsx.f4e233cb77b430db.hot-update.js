"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Sketch_tsx",{

/***/ "(app-pages-browser)/./src/components/Sketch.tsx":
/*!***********************************!*\
  !*** ./src/components/Sketch.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sketch; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Sketch(param) {\n    let { multiHandData, videoRef } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const smoothedLandmarksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHand: null,\n        rightHand: null\n    });\n    const framePersistenceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHandFrames: 0,\n        rightHandFrames: 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let objectVector;\n            let objectSize = 1;\n            let lastObjectSize = 1;\n            let objectSizeSmooth = 0;\n            let grabbing = false;\n            let locked = false;\n            p.setup = ()=>{\n                objectVector = p.createVector(100, 0, 0);\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(60); // Set to 60 FPS for smooth rendering\n                // Use system font instead of loading custom font\n                try {\n                    p.textFont('system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif');\n                } catch (error) {\n                    console.warn(\"Font loading failed, using default:\", error);\n                    // Fallback to default font\n                    p.textFont(\"Arial\");\n                }\n                p.textSize(12);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                p.pop();\n                // Enhanced gesture display\n                p.strokeWeight(5);\n                // Color based on gesture type (using primary hand)\n                let gestureColor;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                if (primaryHand) {\n                    switch(primaryHand.gesture){\n                        case \"pinch\":\n                            gestureColor = p.color(255, 0, 0); // Red\n                            break;\n                        case \"fist\":\n                            gestureColor = p.color(255, 165, 0); // Orange\n                            break;\n                        case \"openHand\":\n                            gestureColor = p.color(0, 255, 0); // Green\n                            break;\n                        case \"pointing\":\n                            gestureColor = p.color(0, 255, 255); // Cyan\n                            break;\n                        case \"victory\":\n                            gestureColor = p.color(255, 0, 255); // Magenta\n                            break;\n                        default:\n                            gestureColor = p.color(128, 128, 128); // Gray\n                    }\n                } else {\n                    gestureColor = p.color(128, 128, 128); // Gray\n                }\n                p.stroke(gestureColor);\n                // Draw gesture indicator line\n                const lineLength = primaryHand ? primaryHand.confidence * 300 : 0;\n                p.line(0, 0, lineLength, 0);\n                // Draw object which is being dragged\n                p.push();\n                p.fill(0, 0, 255, 100);\n                p.stroke(0, 0, 255);\n                p.translate(objectVector.x, objectVector.y, objectVector.z);\n                p.ellipse(0, 0, 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth), 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth));\n                p.pop();\n                // Draw landmarks\n                displayResults(p);\n                // Enhanced gesture-based interaction\n                if ((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) === \"pinch\") {\n                    grabbing = true;\n                } else {\n                    grabbing = false;\n                }\n                // Handle grabbing interaction with the object\n                if (grabbing && primaryHand) {\n                    // Use thumb tip (4) and index tip (8) for pinch position\n                    const thumbTip = primaryHand.landmarks[4];\n                    const indexTip = primaryHand.landmarks[8];\n                    // Calculate pinch center position\n                    const pinchX = (thumbTip.x + indexTip.x) / 2;\n                    const pinchY = (thumbTip.y + indexTip.y) / 2;\n                    const pinchZ = (thumbTip.z + indexTip.z) / 2;\n                    // Map to world coordinates\n                    let pinchVector = p.createVector(pinchX * p.width - p.width / 2, pinchY * p.height - p.height / 2, pinchZ);\n                    if (p.dist(pinchVector.x, pinchVector.y, objectVector.x, objectVector.y) < 50 && locked == false) {\n                        locked = true;\n                        objectSize = 2;\n                    }\n                    if (locked) {\n                        objectVector.x = pinchVector.x;\n                        objectVector.y = pinchVector.y;\n                        objectVector.z = pinchVector.z;\n                    }\n                } else {\n                    locked = false;\n                    objectSize = 1;\n                }\n                // Smooth object size\n                objectSizeSmooth = objectSize * 0.5 + lastObjectSize * 0.5;\n                lastObjectSize = objectSizeSmooth;\n                // Draw privacy indicator only\n                drawPrivacyIndicator(p);\n            };\n            // Enhanced smoothing with persistence\n            const smoothLandmarks = function(currentLandmarks, previousLandmarks) {\n                let smoothingFactor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n                if (!currentLandmarks || currentLandmarks.length === 0) {\n                    return previousLandmarks; // Keep previous landmarks if no new ones\n                }\n                if (!previousLandmarks || previousLandmarks.length !== currentLandmarks.length) {\n                    return currentLandmarks;\n                }\n                return currentLandmarks.map((landmark, index)=>{\n                    const prev = previousLandmarks[index];\n                    if (!prev) return landmark;\n                    // More aggressive smoothing for stability\n                    return {\n                        x: prev.x + (landmark.x - prev.x) * smoothingFactor,\n                        y: prev.y + (landmark.y - prev.y) * smoothingFactor,\n                        z: prev.z + (landmark.z - prev.z) * smoothingFactor\n                    };\n                });\n            };\n            function displayResults(p) {\n                // Smooth left hand landmarks\n                if (multiHandData.leftHand) {\n                    const smoothedLeft = smoothLandmarks(multiHandData.leftHand.landmarks, smoothedLandmarksRef.current.leftHand);\n                    smoothedLandmarksRef.current.leftHand = smoothedLeft;\n                    if (smoothedLeft) {\n                        // Draw left hand landmarks (green)\n                        p.stroke(0, 255, 0); // Green for left hand\n                        p.strokeWeight(4);\n                        p.fill(0, 255, 0, 100);\n                        // Draw connections between landmarks for better visualization\n                        for(let i = 0; i < smoothedLeft.length; i++){\n                            const landmark = smoothedLeft[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            // Draw landmark point\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(3);\n                            p.pop();\n                        }\n                        // Draw hand connections (finger bones)\n                        drawHandConnections(p, smoothedLeft, 0, 255, 0);\n                    }\n                } else {\n                    // Keep previous landmarks for a few frames to prevent flashing\n                    if (smoothedLandmarksRef.current.leftHand) {\n                        const lastLeft = smoothedLandmarksRef.current.leftHand;\n                        p.stroke(0, 255, 0, 50); // Fade out\n                        p.strokeWeight(2);\n                        p.fill(0, 255, 0, 30);\n                        for(let i = 0; i < lastLeft.length; i++){\n                            const landmark = lastLeft[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(2);\n                            p.pop();\n                        }\n                    }\n                }\n                // Smooth right hand landmarks\n                if (multiHandData.rightHand) {\n                    const smoothedRight = smoothLandmarks(multiHandData.rightHand.landmarks, smoothedLandmarksRef.current.rightHand);\n                    smoothedLandmarksRef.current.rightHand = smoothedRight;\n                    if (smoothedRight) {\n                        // Draw right hand landmarks (blue)\n                        p.stroke(0, 0, 255); // Blue for right hand\n                        p.strokeWeight(4);\n                        p.fill(0, 0, 255, 100);\n                        // Draw connections between landmarks for better visualization\n                        for(let i = 0; i < smoothedRight.length; i++){\n                            const landmark = smoothedRight[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            // Draw landmark point\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(3);\n                            p.pop();\n                        }\n                        // Draw hand connections (finger bones)\n                        drawHandConnections(p, smoothedRight, 0, 0, 255);\n                    }\n                } else {\n                    // Keep previous landmarks for a few frames to prevent flashing\n                    if (smoothedLandmarksRef.current.rightHand) {\n                        const lastRight = smoothedLandmarksRef.current.rightHand;\n                        p.stroke(0, 0, 255, 50); // Fade out\n                        p.strokeWeight(2);\n                        p.fill(0, 0, 255, 30);\n                        for(let i = 0; i < lastRight.length; i++){\n                            const landmark = lastRight[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            p.push();\n                            p.translate(x, y, z);\n                            p.pop();\n                        }\n                    }\n                }\n            }\n            function drawHandConnections(p, landmarks, r, g, b) {\n                // MediaPipe hand connections (finger bones)\n                const connections = [\n                    // Thumb\n                    [\n                        0,\n                        1\n                    ],\n                    [\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        3\n                    ],\n                    [\n                        3,\n                        4\n                    ],\n                    // Index finger\n                    [\n                        0,\n                        5\n                    ],\n                    [\n                        5,\n                        6\n                    ],\n                    [\n                        6,\n                        7\n                    ],\n                    [\n                        7,\n                        8\n                    ],\n                    // Middle finger\n                    [\n                        0,\n                        9\n                    ],\n                    [\n                        9,\n                        10\n                    ],\n                    [\n                        10,\n                        11\n                    ],\n                    [\n                        11,\n                        12\n                    ],\n                    // Ring finger\n                    [\n                        0,\n                        13\n                    ],\n                    [\n                        13,\n                        14\n                    ],\n                    [\n                        14,\n                        15\n                    ],\n                    [\n                        15,\n                        16\n                    ],\n                    // Pinky\n                    [\n                        0,\n                        17\n                    ],\n                    [\n                        17,\n                        18\n                    ],\n                    [\n                        18,\n                        19\n                    ],\n                    [\n                        19,\n                        20\n                    ],\n                    // Palm connections\n                    [\n                        5,\n                        9\n                    ],\n                    [\n                        9,\n                        13\n                    ],\n                    [\n                        13,\n                        17\n                    ]\n                ];\n                p.stroke(r, g, b, 150);\n                p.strokeWeight(2);\n                p.noFill();\n                for (const [start, end] of connections){\n                    if (landmarks[start] && landmarks[end]) {\n                        const startX = landmarks[start].x * p.width - p.width / 2;\n                        const startY = landmarks[start].y * p.height - p.height / 2;\n                        const startZ = landmarks[start].z;\n                        const endX = landmarks[end].x * p.width - p.width / 2;\n                        const endY = landmarks[end].y * p.height - p.height / 2;\n                        const endZ = landmarks[end].z;\n                        p.line(startX, startY, startZ, endX, endY, endZ);\n                    }\n                }\n            }\n            function drawGestureDebug(p) {\n                p.push();\n                p.fill(255);\n                p.textAlign(p.LEFT);\n                p.textSize(14);\n                let yPos = -p.height / 2 + 20;\n                p.text(\"Multi-Hand Gesture Debug:\", -p.width / 2 + 10, yPos);\n                yPos += 20;\n                // Left hand info\n                if (multiHandData.leftHand) {\n                    p.text(\"Left Hand: \".concat(multiHandData.leftHand.gesture, \" (\").concat(Math.round(multiHandData.leftHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Left Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Right hand info\n                if (multiHandData.rightHand) {\n                    p.text(\"Right Hand: \".concat(multiHandData.rightHand.gesture, \" (\").concat(Math.round(multiHandData.rightHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Right Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Combined info\n                yPos += 10;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                p.text(\"Primary: \".concat((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) || \"None\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Confidence: \".concat(Math.round(((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.confidence) || 0) * 100), \"%\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Hands Detected: \".concat(multiHandData.totalHands), -p.width / 2 + 10, yPos);\n                p.pop();\n            }\n            function drawPrivacyIndicator(p) {\n                p.push();\n                p.fill(0, 255, 0, 150);\n                p.textAlign(p.RIGHT);\n                p.textSize(12);\n                // Draw privacy indicator in top-right corner\n                p.text(\"Privacy Mode: Hand Tracking Only\", p.width / 2 - 10, -p.height / 2 + 20);\n                p.pop();\n            }\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        multiHandData\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Sketch.tsx\",\n        lineNumber: 389,\n        columnNumber: 10\n    }, this);\n}\n_s(Sketch, \"umpYknO+N0S2uVmhqVc72AyrWQg=\");\n_c = Sketch;\nvar _c;\n$RefreshReg$(_c, \"Sketch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFMEM7QUFDdEI7QUFRTCxTQUFTRyxPQUFPLEtBQXdDO1FBQXhDLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFlLEdBQXhDOztJQUM3QixNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUN4QyxNQUFNTyx1QkFBdUJQLDZDQUFNQSxDQUdoQztRQUFFUSxVQUFVO1FBQU1DLFdBQVc7SUFBSztJQUVyQyxNQUFNQyxzQkFBc0JWLDZDQUFNQSxDQUcvQjtRQUFFVyxnQkFBZ0I7UUFBR0MsaUJBQWlCO0lBQUU7SUFFM0NiLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDTSxVQUFVUSxPQUFPLEVBQUU7UUFFeEIsTUFBTUMsU0FBUyxDQUFDQztZQUNkLElBQUlDO1lBQ0osSUFBSUMsYUFBYTtZQUNqQixJQUFJQyxpQkFBaUI7WUFDckIsSUFBSUMsbUJBQW1CO1lBQ3ZCLElBQUlDLFdBQVc7WUFDZixJQUFJQyxTQUFTO1lBRWJOLEVBQUVPLEtBQUssR0FBRztnQkFDUk4sZUFBZUQsRUFBRVEsWUFBWSxDQUFDLEtBQUssR0FBRztnQkFDdENSLEVBQUVTLFlBQVksQ0FBQyxLQUFLLEtBQUtULEVBQUVVLEtBQUs7Z0JBQ2hDVixFQUFFVyxTQUFTLENBQUMsS0FBSyxxQ0FBcUM7Z0JBRXRELGlEQUFpRDtnQkFDakQsSUFBSTtvQkFDRlgsRUFBRVksUUFBUSxDQUFDO2dCQUNiLEVBQUUsT0FBT0MsT0FBTztvQkFDZEMsUUFBUUMsSUFBSSxDQUFDLHVDQUF1Q0Y7b0JBQ3BELDJCQUEyQjtvQkFDM0JiLEVBQUVZLFFBQVEsQ0FBQztnQkFDYjtnQkFDQVosRUFBRWdCLFFBQVEsQ0FBQztZQUNiO1lBRUFoQixFQUFFaUIsSUFBSSxHQUFHO2dCQUNQakIsRUFBRWtCLEtBQUs7Z0JBQ1BsQixFQUFF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L0YsY0FBY08sT0FBTyxHQUFHO1lBQzFCO1FBQ0Y7SUFDRixHQUFHO1FBQUNWO0tBQWM7SUFFbEIscUJBQU8sOERBQUNtRztRQUFJQyxLQUFLbEc7Ozs7OztBQUNuQjtHQTFYd0JIO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3g/Mzc0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHA1IGZyb20gJ3A1JztcbmltcG9ydCB7IE11bHRpSGFuZERhdGEgfSBmcm9tICdAL3R5cGVzJztcblxuaW50ZXJmYWNlIFNrZXRjaFByb3BzIHtcbiAgbXVsdGlIYW5kRGF0YTogTXVsdGlIYW5kRGF0YTtcbiAgdmlkZW9SZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MVmlkZW9FbGVtZW50Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2tldGNoKHsgbXVsdGlIYW5kRGF0YSwgdmlkZW9SZWYgfTogU2tldGNoUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgcDVJbnN0YW5jZVJlZiA9IHVzZVJlZjxwNSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzbW9vdGhlZExhbmRtYXJrc1JlZiA9IHVzZVJlZjx7XG4gICAgbGVmdEhhbmQ6IGFueVtdIHwgbnVsbDtcbiAgICByaWdodEhhbmQ6IGFueVtdIHwgbnVsbDtcbiAgfT4oeyBsZWZ0SGFuZDogbnVsbCwgcmlnaHRIYW5kOiBudWxsIH0pO1xuICBcbiAgY29uc3QgZnJhbWVQZXJzaXN0ZW5jZVJlZiA9IHVzZVJlZjx7XG4gICAgbGVmdEhhbmRGcmFtZXM6IG51bWJlcjtcbiAgICByaWdodEhhbmRGcmFtZXM6IG51bWJlcjtcbiAgfT4oeyBsZWZ0SGFuZEZyYW1lczogMCwgcmlnaHRIYW5kRnJhbWVzOiAwIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2tldGNoID0gKHA6IHA1KSA9PiB7XG4gICAgICBsZXQgb2JqZWN0VmVjdG9yOiBwNS5WZWN0b3I7XG4gICAgICBsZXQgb2JqZWN0U2l6ZSA9IDE7XG4gICAgICBsZXQgbGFzdE9iamVjdFNpemUgPSAxO1xuICAgICAgbGV0IG9iamVjdFNpemVTbW9vdGggPSAwO1xuICAgICAgbGV0IGdyYWJiaW5nID0gZmFsc2U7XG4gICAgICBsZXQgbG9ja2VkID0gZmFsc2U7XG5cbiAgICAgIHAuc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIG9iamVjdFZlY3RvciA9IHAuY3JlYXRlVmVjdG9yKDEwMCwgMCwgMCk7XG4gICAgICAgIHAuY3JlYXRlQ2FudmFzKDgwMCwgNjQwLCBwLldFQkdMKTtcbiAgICAgICAgcC5mcmFtZVJhdGUoNjApOyAvLyBTZXQgdG8gNjAgRlBTIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgICAgIFxuICAgICAgICAvLyBVc2Ugc3lzdGVtIGZvbnQgaW5zdGVhZCBvZiBsb2FkaW5nIGN1c3RvbSBmb250XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcC50ZXh0Rm9udCgnc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBzYW5zLXNlcmlmJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGb250IGxvYWRpbmcgZmFpbGVkLCB1c2luZyBkZWZhdWx0OicsIGVycm9yKTtcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBkZWZhdWx0IGZvbnRcbiAgICAgICAgICBwLnRleHRGb250KCdBcmlhbCcpO1xuICAgICAgICB9XG4gICAgICAgIHAudGV4dFNpemUoMTIpO1xuICAgICAgfTtcblxuICAgICAgcC5kcmF3ID0gKCkgPT4ge1xuICAgICAgICBwLmNsZWFyKCk7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRyYW5zbGF0ZSgwLCAwLCAtMTAwKTtcbiAgICAgICAgcC5wb3AoKTtcblxuICAgICAgICAvLyBFbmhhbmNlZCBnZXN0dXJlIGRpc3BsYXlcbiAgICAgICAgcC5zdHJva2VXZWlnaHQoNSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb2xvciBiYXNlZCBvbiBnZXN0dXJlIHR5cGUgKHVzaW5nIHByaW1hcnkgaGFuZClcbiAgICAgICAgbGV0IGdlc3R1cmVDb2xvcjtcbiAgICAgICAgY29uc3QgcHJpbWFyeUhhbmQgPSBtdWx0aUhhbmREYXRhLmxlZnRIYW5kIHx8IG11bHRpSGFuZERhdGEucmlnaHRIYW5kO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByaW1hcnlIYW5kKSB7XG4gICAgICAgICAgc3dpdGNoKHByaW1hcnlIYW5kLmdlc3R1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwaW5jaFwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDI1NSwgMCwgMCk7IC8vIFJlZFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaXN0XCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMjU1LCAxNjUsIDApOyAvLyBPcmFuZ2VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3BlbkhhbmRcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigwLCAyNTUsIDApOyAvLyBHcmVlblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGluZ1wiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDAsIDI1NSwgMjU1KTsgLy8gQ3lhblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2aWN0b3J5XCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMjU1LCAwLCAyNTUpOyAvLyBNYWdlbnRhXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigxMjgsIDEyOCwgMTI4KTsgLy8gR3JheVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDEyOCwgMTI4LCAxMjgpOyAvLyBHcmF5XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHAuc3Ryb2tlKGdlc3R1cmVDb2xvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IGdlc3R1cmUgaW5kaWNhdG9yIGxpbmVcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IHByaW1hcnlIYW5kID8gcHJpbWFyeUhhbmQuY29uZmlkZW5jZSAqIDMwMCA6IDA7XG4gICAgICAgIHAubGluZSgwLCAwLCBsaW5lTGVuZ3RoLCAwKTtcblxuICAgICAgICAvLyBEcmF3IG9iamVjdCB3aGljaCBpcyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLmZpbGwoMCwgMCwgMjU1LCAxMDApO1xuICAgICAgICBwLnN0cm9rZSgwLCAwLCAyNTUpO1xuICAgICAgICBwLnRyYW5zbGF0ZShvYmplY3RWZWN0b3IueCwgb2JqZWN0VmVjdG9yLnksIG9iamVjdFZlY3Rvci56KTtcbiAgICAgICAgcC5lbGxpcHNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxMDAgKiBwLm1hcChvYmplY3RWZWN0b3IueiwgMC4xLCAtMC4xLCAwLjEsIG9iamVjdFNpemVTbW9vdGgpLFxuICAgICAgICAgIDEwMCAqIHAubWFwKG9iamVjdFZlY3Rvci56LCAwLjEsIC0wLjEsIDAuMSwgb2JqZWN0U2l6ZVNtb290aClcbiAgICAgICAgKTtcbiAgICAgICAgcC5wb3AoKTtcblxuICAgICAgICAvLyBEcmF3IGxhbmRtYXJrc1xuICAgICAgICBkaXNwbGF5UmVzdWx0cyhwKTtcblxuICAgICAgICAvLyBFbmhhbmNlZCBnZXN0dXJlLWJhc2VkIGludGVyYWN0aW9uXG4gICAgICAgIGlmIChwcmltYXJ5SGFuZD8uZ2VzdHVyZSA9PT0gXCJwaW5jaFwiKSB7XG4gICAgICAgICAgZ3JhYmJpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWJiaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgZ3JhYmJpbmcgaW50ZXJhY3Rpb24gd2l0aCB0aGUgb2JqZWN0XG4gICAgICAgIGlmIChncmFiYmluZyAmJiBwcmltYXJ5SGFuZCkge1xuICAgICAgICAgIC8vIFVzZSB0aHVtYiB0aXAgKDQpIGFuZCBpbmRleCB0aXAgKDgpIGZvciBwaW5jaCBwb3NpdGlvblxuICAgICAgICAgIGNvbnN0IHRodW1iVGlwID0gcHJpbWFyeUhhbmQubGFuZG1hcmtzWzRdO1xuICAgICAgICAgIGNvbnN0IGluZGV4VGlwID0gcHJpbWFyeUhhbmQubGFuZG1hcmtzWzhdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBwaW5jaCBjZW50ZXIgcG9zaXRpb25cbiAgICAgICAgICBjb25zdCBwaW5jaFggPSAodGh1bWJUaXAueCArIGluZGV4VGlwLngpIC8gMjtcbiAgICAgICAgICBjb25zdCBwaW5jaFkgPSAodGh1bWJUaXAueSArIGluZGV4VGlwLnkpIC8gMjtcbiAgICAgICAgICBjb25zdCBwaW5jaFogPSAodGh1bWJUaXAueiArIGluZGV4VGlwLnopIC8gMjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYXAgdG8gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICBsZXQgcGluY2hWZWN0b3IgPSBwLmNyZWF0ZVZlY3RvcihcbiAgICAgICAgICAgIHBpbmNoWCAqIHAud2lkdGggLSBwLndpZHRoIC8gMixcbiAgICAgICAgICAgIHBpbmNoWSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGluY2haXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwLmRpc3QocGluY2hWZWN0b3IueCwgcGluY2hWZWN0b3IueSwgb2JqZWN0VmVjdG9yLngsIG9iamVjdFZlY3Rvci55KSA8IDUwICYmXG4gICAgICAgICAgICBsb2NrZWQgPT0gZmFsc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBvYmplY3RTaXplID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgb2JqZWN0VmVjdG9yLnggPSBwaW5jaFZlY3Rvci54O1xuICAgICAgICAgICAgb2JqZWN0VmVjdG9yLnkgPSBwaW5jaFZlY3Rvci55O1xuICAgICAgICAgICAgb2JqZWN0VmVjdG9yLnogPSBwaW5jaFZlY3Rvci56O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICBvYmplY3RTaXplID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNtb290aCBvYmplY3Qgc2l6ZVxuICAgICAgICBvYmplY3RTaXplU21vb3RoID0gb2JqZWN0U2l6ZSAqIDAuNSArIGxhc3RPYmplY3RTaXplICogMC41O1xuICAgICAgICBsYXN0T2JqZWN0U2l6ZSA9IG9iamVjdFNpemVTbW9vdGg7XG5cbiAgICAgICAgLy8gRHJhdyBwcml2YWN5IGluZGljYXRvciBvbmx5XG4gICAgICAgIGRyYXdQcml2YWN5SW5kaWNhdG9yKHApO1xuICAgICAgfTtcblxuICAgICAgLy8gRW5oYW5jZWQgc21vb3RoaW5nIHdpdGggcGVyc2lzdGVuY2VcbiAgICAgIGNvbnN0IHNtb290aExhbmRtYXJrcyA9IChjdXJyZW50TGFuZG1hcmtzOiBhbnlbXSwgcHJldmlvdXNMYW5kbWFya3M6IGFueVtdIHwgbnVsbCwgc21vb3RoaW5nRmFjdG9yOiBudW1iZXIgPSAwLjIpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGFuZG1hcmtzIHx8IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZpb3VzTGFuZG1hcmtzOyAvLyBLZWVwIHByZXZpb3VzIGxhbmRtYXJrcyBpZiBubyBuZXcgb25lc1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXByZXZpb3VzTGFuZG1hcmtzIHx8IHByZXZpb3VzTGFuZG1hcmtzLmxlbmd0aCAhPT0gY3VycmVudExhbmRtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExhbmRtYXJrcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMYW5kbWFya3MubWFwKChsYW5kbWFyaywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNMYW5kbWFya3NbaW5kZXhdO1xuICAgICAgICAgIGlmICghcHJldikgcmV0dXJuIGxhbmRtYXJrO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1vcmUgYWdncmVzc2l2ZSBzbW9vdGhpbmcgZm9yIHN0YWJpbGl0eVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwcmV2LnggKyAobGFuZG1hcmsueCAtIHByZXYueCkgKiBzbW9vdGhpbmdGYWN0b3IsXG4gICAgICAgICAgICB5OiBwcmV2LnkgKyAobGFuZG1hcmsueSAtIHByZXYueSkgKiBzbW9vdGhpbmdGYWN0b3IsXG4gICAgICAgICAgICB6OiBwcmV2LnogKyAobGFuZG1hcmsueiAtIHByZXYueikgKiBzbW9vdGhpbmdGYWN0b3JcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGRpc3BsYXlSZXN1bHRzKHA6IHA1KSB7XG4gICAgICAgIC8vIFNtb290aCBsZWZ0IGhhbmQgbGFuZG1hcmtzXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLmxlZnRIYW5kKSB7XG4gICAgICAgICAgY29uc3Qgc21vb3RoZWRMZWZ0ID0gc21vb3RoTGFuZG1hcmtzKFxuICAgICAgICAgICAgbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5sYW5kbWFya3MsIFxuICAgICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZCA9IHNtb290aGVkTGVmdDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc21vb3RoZWRMZWZ0KSB7XG4gICAgICAgICAgICAvLyBEcmF3IGxlZnQgaGFuZCBsYW5kbWFya3MgKGdyZWVuKVxuICAgICAgICAgICAgcC5zdHJva2UoMCwgMjU1LCAwKTsgLy8gR3JlZW4gZm9yIGxlZnQgaGFuZFxuICAgICAgICAgICAgcC5zdHJva2VXZWlnaHQoNCk7XG4gICAgICAgICAgICBwLmZpbGwoMCwgMjU1LCAwLCAxMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zIGJldHdlZW4gbGFuZG1hcmtzIGZvciBiZXR0ZXIgdmlzdWFsaXphdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbW9vdGhlZExlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBzbW9vdGhlZExlZnRbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHggPSBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgICBjb25zdCB5ID0gbGFuZG1hcmsueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBjb25zdCB6ID0gbGFuZG1hcmsuejtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIERyYXcgbGFuZG1hcmsgcG9pbnRcbiAgICAgICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgICAgIHAudHJhbnNsYXRlKHgsIHksIHopO1xuICAgICAgICAgICAgICBwLnNwaGVyZSgzKTtcbiAgICAgICAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyBoYW5kIGNvbm5lY3Rpb25zIChmaW5nZXIgYm9uZXMpXG4gICAgICAgICAgICBkcmF3SGFuZENvbm5lY3Rpb25zKHAsIHNtb290aGVkTGVmdCwgMCwgMjU1LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gS2VlcCBwcmV2aW91cyBsYW5kbWFya3MgZm9yIGEgZmV3IGZyYW1lcyB0byBwcmV2ZW50IGZsYXNoaW5nXG4gICAgICAgICAgaWYgKHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQubGVmdEhhbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMZWZ0ID0gc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZDtcbiAgICAgICAgICAgIHAuc3Ryb2tlKDAsIDI1NSwgMCwgNTApOyAvLyBGYWRlIG91dFxuICAgICAgICAgICAgcC5zdHJva2VXZWlnaHQoMik7XG4gICAgICAgICAgICBwLmZpbGwoMCwgMjU1LCAwLCAzMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdExlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYXN0TGVmdFtpXTtcbiAgICAgICAgICAgICAgY29uc3QgeCA9IGxhbmRtYXJrLnggKiBwLndpZHRoIC0gcC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgIGNvbnN0IHkgPSBsYW5kbWFyay55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgIGNvbnN0IHogPSBsYW5kbWFyay56O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgICAgIHAudHJhbnNsYXRlKHgsIHksIHopO1xuICAgICAgICAgICAgICBwLnNwaGVyZSgyKTtcbiAgICAgICAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNtb290aCByaWdodCBoYW5kIGxhbmRtYXJrc1xuICAgICAgICBpZiAobXVsdGlIYW5kRGF0YS5yaWdodEhhbmQpIHtcbiAgICAgICAgICBjb25zdCBzbW9vdGhlZFJpZ2h0ID0gc21vb3RoTGFuZG1hcmtzKFxuICAgICAgICAgICAgbXVsdGlIYW5kRGF0YS5yaWdodEhhbmQubGFuZG1hcmtzLCBcbiAgICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQucmlnaHRIYW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzbW9vdGhlZExhbmRtYXJrc1JlZi5jdXJyZW50LnJpZ2h0SGFuZCA9IHNtb290aGVkUmlnaHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNtb290aGVkUmlnaHQpIHtcbiAgICAgICAgICAgIC8vIERyYXcgcmlnaHQgaGFuZCBsYW5kbWFya3MgKGJsdWUpXG4gICAgICAgICAgICBwLnN0cm9rZSgwLCAwLCAyNTUpOyAvLyBCbHVlIGZvciByaWdodCBoYW5kXG4gICAgICAgICAgICBwLnN0cm9rZVdlaWdodCg0KTtcbiAgICAgICAgICAgIHAuZmlsbCgwLCAwLCAyNTUsIDEwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgY29ubmVjdGlvbnMgYmV0d2VlbiBsYW5kbWFya3MgZm9yIGJldHRlciB2aXN1YWxpemF0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtb290aGVkUmlnaHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBzbW9vdGhlZFJpZ2h0W2ldO1xuICAgICAgICAgICAgICBjb25zdCB4ID0gbGFuZG1hcmsueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeSA9IGxhbmRtYXJrLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBEcmF3IGxhbmRtYXJrIHBvaW50XG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5zcGhlcmUoMyk7XG4gICAgICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgaGFuZCBjb25uZWN0aW9ucyAoZmluZ2VyIGJvbmVzKVxuICAgICAgICAgICAgZHJhd0hhbmRDb25uZWN0aW9ucyhwLCBzbW9vdGhlZFJpZ2h0LCAwLCAwLCAyNTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBLZWVwIHByZXZpb3VzIGxhbmRtYXJrcyBmb3IgYSBmZXcgZnJhbWVzIHRvIHByZXZlbnQgZmxhc2hpbmdcbiAgICAgICAgICBpZiAoc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5yaWdodEhhbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSaWdodCA9IHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQucmlnaHRIYW5kO1xuICAgICAgICAgICAgcC5zdHJva2UoMCwgMCwgMjU1LCA1MCk7IC8vIEZhZGUgb3V0XG4gICAgICAgICAgICBwLnN0cm9rZVdlaWdodCgyKTtcbiAgICAgICAgICAgIHAuZmlsbCgwLCAwLCAyNTUsIDMwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0UmlnaHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYXN0UmlnaHRbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHggPSBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgICBjb25zdCB5ID0gbGFuZG1hcmsueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBjb25zdCB6ID0gbGFuZG1hcmsuejtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd0hhbmRDb25uZWN0aW9ucyhwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgcjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgICAgICAvLyBNZWRpYVBpcGUgaGFuZCBjb25uZWN0aW9ucyAoZmluZ2VyIGJvbmVzKVxuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IFtcbiAgICAgICAgICAvLyBUaHVtYlxuICAgICAgICAgIFswLCAxXSwgWzEsIDJdLCBbMiwgM10sIFszLCA0XSxcbiAgICAgICAgICAvLyBJbmRleCBmaW5nZXJcbiAgICAgICAgICBbMCwgNV0sIFs1LCA2XSwgWzYsIDddLCBbNywgOF0sXG4gICAgICAgICAgLy8gTWlkZGxlIGZpbmdlclxuICAgICAgICAgIFswLCA5XSwgWzksIDEwXSwgWzEwLCAxMV0sIFsxMSwgMTJdLFxuICAgICAgICAgIC8vIFJpbmcgZmluZ2VyXG4gICAgICAgICAgWzAsIDEzXSwgWzEzLCAxNF0sIFsxNCwgMTVdLCBbMTUsIDE2XSxcbiAgICAgICAgICAvLyBQaW5reVxuICAgICAgICAgIFswLCAxN10sIFsxNywgMThdLCBbMTgsIDE5XSwgWzE5LCAyMF0sXG4gICAgICAgICAgLy8gUGFsbSBjb25uZWN0aW9uc1xuICAgICAgICAgIFs1LCA5XSwgWzksIDEzXSwgWzEzLCAxN11cbiAgICAgICAgXTtcblxuICAgICAgICBwLnN0cm9rZShyLCBnLCBiLCAxNTApO1xuICAgICAgICBwLnN0cm9rZVdlaWdodCgyKTtcbiAgICAgICAgcC5ub0ZpbGwoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBjb25uZWN0aW9ucykge1xuICAgICAgICAgIGlmIChsYW5kbWFya3Nbc3RhcnRdICYmIGxhbmRtYXJrc1tlbmRdKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSBsYW5kbWFya3Nbc3RhcnRdLnggKiBwLndpZHRoIC0gcC53aWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBsYW5kbWFya3Nbc3RhcnRdLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WiA9IGxhbmRtYXJrc1tzdGFydF0uejtcbiAgICAgICAgICAgIGNvbnN0IGVuZFggPSBsYW5kbWFya3NbZW5kXS54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgZW5kWSA9IGxhbmRtYXJrc1tlbmRdLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGVuZFogPSBsYW5kbWFya3NbZW5kXS56O1xuXG4gICAgICAgICAgICBwLmxpbmUoc3RhcnRYLCBzdGFydFksIHN0YXJ0WiwgZW5kWCwgZW5kWSwgZW5kWik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdHZXN0dXJlRGVidWcocDogcDUpIHtcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAuZmlsbCgyNTUpO1xuICAgICAgICBwLnRleHRBbGlnbihwLkxFRlQpO1xuICAgICAgICBwLnRleHRTaXplKDE0KTtcbiAgICAgICAgXG4gICAgICAgIGxldCB5UG9zID0gLXAuaGVpZ2h0LzIgKyAyMDtcbiAgICAgICAgcC50ZXh0KFwiTXVsdGktSGFuZCBHZXN0dXJlIERlYnVnOlwiLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICB5UG9zICs9IDIwO1xuICAgICAgICBcbiAgICAgICAgLy8gTGVmdCBoYW5kIGluZm9cbiAgICAgICAgaWYgKG11bHRpSGFuZERhdGEubGVmdEhhbmQpIHtcbiAgICAgICAgICBwLnRleHQoYExlZnQgSGFuZDogJHttdWx0aUhhbmREYXRhLmxlZnRIYW5kLmdlc3R1cmV9ICgke01hdGgucm91bmQobXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5jb25maWRlbmNlICogMTAwKX0lKWAsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRleHQoXCJMZWZ0IEhhbmQ6IE5vdCBkZXRlY3RlZFwiLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJpZ2h0IGhhbmQgaW5mb1xuICAgICAgICBpZiAobXVsdGlIYW5kRGF0YS5yaWdodEhhbmQpIHtcbiAgICAgICAgICBwLnRleHQoYFJpZ2h0IEhhbmQ6ICR7bXVsdGlIYW5kRGF0YS5yaWdodEhhbmQuZ2VzdHVyZX0gKCR7TWF0aC5yb3VuZChtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZC5jb25maWRlbmNlICogMTAwKX0lKWAsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRleHQoXCJSaWdodCBIYW5kOiBOb3QgZGV0ZWN0ZWRcIiwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDb21iaW5lZCBpbmZvXG4gICAgICAgIHlQb3MgKz0gMTA7XG4gICAgICAgIGNvbnN0IHByaW1hcnlIYW5kID0gbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZCB8fCBtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZDtcbiAgICAgICAgcC50ZXh0KGBQcmltYXJ5OiAke3ByaW1hcnlIYW5kPy5nZXN0dXJlIHx8ICdOb25lJ31gLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICBwLnRleHQoYENvbmZpZGVuY2U6ICR7TWF0aC5yb3VuZCgocHJpbWFyeUhhbmQ/LmNvbmZpZGVuY2UgfHwgMCkgKiAxMDApfSVgLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICBwLnRleHQoYEhhbmRzIERldGVjdGVkOiAke211bHRpSGFuZERhdGEudG90YWxIYW5kc31gLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd1ByaXZhY3lJbmRpY2F0b3IocDogcDUpIHtcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAuZmlsbCgwLCAyNTUsIDAsIDE1MCk7XG4gICAgICAgIHAudGV4dEFsaWduKHAuUklHSFQpO1xuICAgICAgICBwLnRleHRTaXplKDEyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcHJpdmFjeSBpbmRpY2F0b3IgaW4gdG9wLXJpZ2h0IGNvcm5lclxuICAgICAgICBwLnRleHQoXCJQcml2YWN5IE1vZGU6IEhhbmQgVHJhY2tpbmcgT25seVwiLCBwLndpZHRoLzIgLSAxMCwgLXAuaGVpZ2h0LzIgKyAyMCk7XG4gICAgICAgIFxuICAgICAgICBwLnBvcCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQgPSBuZXcgcDUoc2tldGNoLCBjYW52YXNSZWYuY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHA1SW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW211bHRpSGFuZERhdGFdKTtcblxuICByZXR1cm4gPGRpdiByZWY9e2NhbnZhc1JlZn0gLz47XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJwNSIsIlNrZXRjaCIsIm11bHRpSGFuZERhdGEiLCJ2aWRlb1JlZiIsImNhbnZhc1JlZiIsInA1SW5zdGFuY2VSZWYiLCJzbW9vdGhlZExhbmRtYXJrc1JlZiIsImxlZnRIYW5kIiwicmlnaHRIYW5kIiwiZnJhbWVQZXJzaXN0ZW5jZVJlZiIsImxlZnRIYW5kRnJhbWVzIiwicmlnaHRIYW5kRnJhbWVzIiwiY3VycmVudCIsInNrZXRjaCIsInAiLCJvYmplY3RWZWN0b3IiLCJvYmplY3RTaXplIiwibGFzdE9iamVjdFNpemUiLCJvYmplY3RTaXplU21vb3RoIiwiZ3JhYmJpbmciLCJsb2NrZWQiLCJzZXR1cCIsImNyZWF0ZVZlY3RvciIsImNyZWF0ZUNhbnZhcyIsIldFQkdMIiwiZnJhbWVSYXRlIiwidGV4dEZvbnQiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwidGV4dFNpemUiLCJkcmF3IiwiY2xlYXIiLCJwdXNoIiwidHJhbnNsYXRlIiwicG9wIiwic3Ryb2tlV2VpZ2h0IiwiZ2VzdHVyZUNvbG9yIiwicHJpbWFyeUhhbmQiLCJnZXN0dXJlIiwiY29sb3IiLCJzdHJva2UiLCJsaW5lTGVuZ3RoIiwiY29uZmlkZW5jZSIsImxpbmUiLCJmaWxsIiwieCIsInkiLCJ6IiwiZWxsaXBzZSIsIm1hcCIsImRpc3BsYXlSZXN1bHRzIiwidGh1bWJUaXAiLCJsYW5kbWFya3MiLCJpbmRleFRpcCIsInBpbmNoWCIsInBpbmNoWSIsInBpbmNoWiIsInBpbmNoVmVjdG9yIiwid2lkdGgiLCJoZWlnaHQiLCJkaXN0IiwiZHJhd1ByaXZhY3lJbmRpY2F0b3IiLCJzbW9vdGhMYW5kbWFya3MiLCJjdXJyZW50TGFuZG1hcmtzIiwicHJldmlvdXNMYW5kbWFya3MiLCJzbW9vdGhpbmdGYWN0b3IiLCJsZW5ndGgiLCJsYW5kbWFyayIsImluZGV4IiwicHJldiIsInNtb290aGVkTGVmdCIsImkiLCJzcGhlcmUiLCJkcmF3SGFuZENvbm5lY3Rpb25zIiwibGFzdExlZnQiLCJzbW9vdGhlZFJpZ2h0IiwibGFzdFJpZ2h0IiwiciIsImciLCJiIiwiY29ubmVjdGlvbnMiLCJub0ZpbGwiLCJzdGFydCIsImVuZCIsInN0YXJ0WCIsInN0YXJ0WSIsInN0YXJ0WiIsImVuZFgiLCJlbmRZIiwiZW5kWiIsImRyYXdHZXN0dXJlRGVidWciLCJ0ZXh0QWxpZ24iLCJMRUZUIiwieVBvcyIsInRleHQiLCJNYXRoIiwicm91bmQiLCJ0b3RhbEhhbmRzIiwiUklHSFQiLCJyZW1vdmUiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Sketch.tsx\n"));

/***/ })

});
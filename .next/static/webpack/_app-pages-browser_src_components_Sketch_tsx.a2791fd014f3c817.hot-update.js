"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Sketch_tsx",{

/***/ "(app-pages-browser)/./src/components/Sketch.tsx":
/*!***********************************!*\
  !*** ./src/components/Sketch.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sketch; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Sketch(param) {\n    let { multiHandData, videoRef } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const smoothedLandmarksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHand: null,\n        rightHand: null\n    });\n    const framePersistenceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHandFrames: 0,\n        rightHandFrames: 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let objectVector;\n            let objectSize = 1;\n            let lastObjectSize = 1;\n            let objectSizeSmooth = 0;\n            let grabbing = false;\n            let locked = false;\n            p.setup = ()=>{\n                objectVector = p.createVector(100, 0, 0);\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(60); // Set to 60 FPS for smooth rendering\n                // Use system font instead of loading custom font\n                try {\n                    p.textFont('system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif');\n                } catch (error) {\n                    console.warn(\"Font loading failed, using default:\", error);\n                    // Fallback to default font\n                    p.textFont(\"Arial\");\n                }\n                p.textSize(12);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                p.pop();\n                // Enhanced gesture display\n                p.strokeWeight(5);\n                // Color based on gesture type (using primary hand)\n                let gestureColor;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                if (primaryHand) {\n                    switch(primaryHand.gesture){\n                        case \"pinch\":\n                            gestureColor = p.color(255, 0, 0); // Red\n                            break;\n                        case \"fist\":\n                            gestureColor = p.color(255, 165, 0); // Orange\n                            break;\n                        case \"openHand\":\n                            gestureColor = p.color(0, 255, 0); // Green\n                            break;\n                        case \"pointing\":\n                            gestureColor = p.color(0, 255, 255); // Cyan\n                            break;\n                        case \"victory\":\n                            gestureColor = p.color(255, 0, 255); // Magenta\n                            break;\n                        default:\n                            gestureColor = p.color(128, 128, 128); // Gray\n                    }\n                } else {\n                    gestureColor = p.color(128, 128, 128); // Gray\n                }\n                p.stroke(gestureColor);\n                // Draw gesture indicator line\n                const lineLength = primaryHand ? primaryHand.confidence * 300 : 0;\n                p.line(0, 0, lineLength, 0);\n                // Draw object which is being dragged\n                p.push();\n                p.fill(0, 0, 255, 100);\n                p.stroke(0, 0, 255);\n                p.translate(objectVector.x, objectVector.y, objectVector.z);\n                p.ellipse(0, 0, 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth), 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth));\n                p.pop();\n                // Draw landmarks\n                displayResults(p);\n                // Enhanced gesture-based interaction\n                if ((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) === \"pinch\") {\n                    grabbing = true;\n                } else {\n                    grabbing = false;\n                }\n                // Handle grabbing interaction with the object\n                if (grabbing && primaryHand) {\n                    // Use thumb tip (4) and index tip (8) for pinch position\n                    const thumbTip = primaryHand.landmarks[4];\n                    const indexTip = primaryHand.landmarks[8];\n                    // Calculate pinch center position\n                    const pinchX = (thumbTip.x + indexTip.x) / 2;\n                    const pinchY = (thumbTip.y + indexTip.y) / 2;\n                    const pinchZ = (thumbTip.z + indexTip.z) / 2;\n                    // Map to world coordinates\n                    let pinchVector = p.createVector(pinchX * p.width - p.width / 2, pinchY * p.height - p.height / 2, pinchZ);\n                    if (p.dist(pinchVector.x, pinchVector.y, objectVector.x, objectVector.y) < 50 && locked == false) {\n                        locked = true;\n                        objectSize = 2;\n                    }\n                    if (locked) {\n                        objectVector.x = pinchVector.x;\n                        objectVector.y = pinchVector.y;\n                        objectVector.z = pinchVector.z;\n                    }\n                } else {\n                    locked = false;\n                    objectSize = 1;\n                }\n                // Smooth object size\n                objectSizeSmooth = objectSize * 0.5 + lastObjectSize * 0.5;\n                lastObjectSize = objectSizeSmooth;\n                // Draw privacy indicator only\n                drawPrivacyIndicator(p);\n            };\n            // Simple and stable landmark processing (based on reference code)\n            const processLandmarks = (landmarks)=>{\n                if (!landmarks || landmarks.length === 0) return null;\n                // Simple mapping without complex smoothing\n                return landmarks.map((landmark)=>({\n                        x: landmark.x,\n                        y: landmark.y,\n                        z: landmark.z\n                    }));\n            };\n            function displayResults(p) {\n                // Smooth left hand landmarks with persistence\n                if (multiHandData.leftHand) {\n                    const smoothedLeft = smoothLandmarks(multiHandData.leftHand.landmarks, smoothedLandmarksRef.current.leftHand);\n                    smoothedLandmarksRef.current.leftHand = smoothedLeft;\n                    framePersistenceRef.current.leftHandFrames = 0; // Reset counter\n                    if (smoothedLeft) {\n                        // Draw left hand landmarks (green)\n                        p.stroke(0, 255, 0); // Green for left hand\n                        p.strokeWeight(4);\n                        p.fill(0, 255, 0, 100);\n                        // Draw connections between landmarks for better visualization\n                        for(let i = 0; i < smoothedLeft.length; i++){\n                            const landmark = smoothedLeft[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            // Draw landmark point\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(3);\n                            p.pop();\n                        }\n                        // Draw hand connections (finger bones)\n                        drawHandConnections(p, smoothedLeft, 0, 255, 0);\n                    }\n                } else {\n                    // Keep previous landmarks for several frames to prevent flashing\n                    framePersistenceRef.current.leftHandFrames++;\n                    const maxPersistenceFrames = 10; // Keep for 10 frames\n                    if (smoothedLandmarksRef.current.leftHand && framePersistenceRef.current.leftHandFrames < maxPersistenceFrames) {\n                        const lastLeft = smoothedLandmarksRef.current.leftHand;\n                        const fadeAlpha = Math.max(0, 255 - framePersistenceRef.current.leftHandFrames * 25); // Gradual fade\n                        p.stroke(0, 255, 0, fadeAlpha);\n                        p.strokeWeight(2);\n                        p.fill(0, 255, 0, fadeAlpha * 0.3);\n                        for(let i = 0; i < lastLeft.length; i++){\n                            const landmark = lastLeft[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(2);\n                            p.pop();\n                        }\n                    } else if (framePersistenceRef.current.leftHandFrames >= maxPersistenceFrames) {\n                        smoothedLandmarksRef.current.leftHand = null; // Clear after persistence\n                    }\n                }\n                // Smooth right hand landmarks with persistence\n                if (multiHandData.rightHand) {\n                    const smoothedRight = smoothLandmarks(multiHandData.rightHand.landmarks, smoothedLandmarksRef.current.rightHand);\n                    smoothedLandmarksRef.current.rightHand = smoothedRight;\n                    framePersistenceRef.current.rightHandFrames = 0; // Reset counter\n                    if (smoothedRight) {\n                        // Draw right hand landmarks (blue)\n                        p.stroke(0, 0, 255); // Blue for right hand\n                        p.strokeWeight(4);\n                        p.fill(0, 0, 255, 100);\n                        // Draw connections between landmarks for better visualization\n                        for(let i = 0; i < smoothedRight.length; i++){\n                            const landmark = smoothedRight[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            // Draw landmark point\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(3);\n                            p.pop();\n                        }\n                        // Draw hand connections (finger bones)\n                        drawHandConnections(p, smoothedRight, 0, 0, 255);\n                    }\n                } else {\n                    // Keep previous landmarks for several frames to prevent flashing\n                    framePersistenceRef.current.rightHandFrames++;\n                    const maxPersistenceFrames = 10; // Keep for 10 frames\n                    if (smoothedLandmarksRef.current.rightHand && framePersistenceRef.current.rightHandFrames < maxPersistenceFrames) {\n                        const lastRight = smoothedLandmarksRef.current.rightHand;\n                        const fadeAlpha = Math.max(0, 255 - framePersistenceRef.current.rightHandFrames * 25); // Gradual fade\n                        p.stroke(0, 0, 255, fadeAlpha);\n                        p.strokeWeight(2);\n                        p.fill(0, 0, 255, fadeAlpha * 0.3);\n                        for(let i = 0; i < lastRight.length; i++){\n                            const landmark = lastRight[i];\n                            const x = landmark.x * p.width - p.width / 2;\n                            const y = landmark.y * p.height - p.height / 2;\n                            const z = landmark.z;\n                            p.push();\n                            p.translate(x, y, z);\n                            p.sphere(2);\n                            p.pop();\n                        }\n                    } else if (framePersistenceRef.current.rightHandFrames >= maxPersistenceFrames) {\n                        smoothedLandmarksRef.current.rightHand = null; // Clear after persistence\n                    }\n                }\n            }\n            function drawHandConnections(p, landmarks, r, g, b) {\n                // MediaPipe hand connections (finger bones)\n                const connections = [\n                    // Thumb\n                    [\n                        0,\n                        1\n                    ],\n                    [\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        3\n                    ],\n                    [\n                        3,\n                        4\n                    ],\n                    // Index finger\n                    [\n                        0,\n                        5\n                    ],\n                    [\n                        5,\n                        6\n                    ],\n                    [\n                        6,\n                        7\n                    ],\n                    [\n                        7,\n                        8\n                    ],\n                    // Middle finger\n                    [\n                        0,\n                        9\n                    ],\n                    [\n                        9,\n                        10\n                    ],\n                    [\n                        10,\n                        11\n                    ],\n                    [\n                        11,\n                        12\n                    ],\n                    // Ring finger\n                    [\n                        0,\n                        13\n                    ],\n                    [\n                        13,\n                        14\n                    ],\n                    [\n                        14,\n                        15\n                    ],\n                    [\n                        15,\n                        16\n                    ],\n                    // Pinky\n                    [\n                        0,\n                        17\n                    ],\n                    [\n                        17,\n                        18\n                    ],\n                    [\n                        18,\n                        19\n                    ],\n                    [\n                        19,\n                        20\n                    ],\n                    // Palm connections\n                    [\n                        5,\n                        9\n                    ],\n                    [\n                        9,\n                        13\n                    ],\n                    [\n                        13,\n                        17\n                    ]\n                ];\n                p.stroke(r, g, b, 150);\n                p.strokeWeight(2);\n                p.noFill();\n                for (const [start, end] of connections){\n                    if (landmarks[start] && landmarks[end]) {\n                        const startX = landmarks[start].x * p.width - p.width / 2;\n                        const startY = landmarks[start].y * p.height - p.height / 2;\n                        const startZ = landmarks[start].z;\n                        const endX = landmarks[end].x * p.width - p.width / 2;\n                        const endY = landmarks[end].y * p.height - p.height / 2;\n                        const endZ = landmarks[end].z;\n                        p.line(startX, startY, startZ, endX, endY, endZ);\n                    }\n                }\n            }\n            function drawGestureDebug(p) {\n                p.push();\n                p.fill(255);\n                p.textAlign(p.LEFT);\n                p.textSize(14);\n                let yPos = -p.height / 2 + 20;\n                p.text(\"Multi-Hand Gesture Debug:\", -p.width / 2 + 10, yPos);\n                yPos += 20;\n                // Left hand info\n                if (multiHandData.leftHand) {\n                    p.text(\"Left Hand: \".concat(multiHandData.leftHand.gesture, \" (\").concat(Math.round(multiHandData.leftHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Left Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Right hand info\n                if (multiHandData.rightHand) {\n                    p.text(\"Right Hand: \".concat(multiHandData.rightHand.gesture, \" (\").concat(Math.round(multiHandData.rightHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Right Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Combined info\n                yPos += 10;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                p.text(\"Primary: \".concat((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) || \"None\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Confidence: \".concat(Math.round(((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.confidence) || 0) * 100), \"%\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Hands Detected: \".concat(multiHandData.totalHands), -p.width / 2 + 10, yPos);\n                p.pop();\n            }\n            function drawPrivacyIndicator(p) {\n                p.push();\n                p.fill(0, 255, 0, 150);\n                p.textAlign(p.RIGHT);\n                p.textSize(12);\n                // Draw privacy indicator in top-right corner\n                p.text(\"Privacy Mode: Hand Tracking Only\", p.width / 2 - 10, -p.height / 2 + 20);\n                p.pop();\n            }\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        multiHandData\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Sketch.tsx\",\n        lineNumber: 395,\n        columnNumber: 10\n    }, this);\n}\n_s(Sketch, \"umpYknO+N0S2uVmhqVc72AyrWQg=\");\n_c = Sketch;\nvar _c;\n$RefreshReg$(_c, \"Sketch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFMEM7QUFDdEI7QUFRTCxTQUFTRyxPQUFPLEtBQXdDO1FBQXhDLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFlLEdBQXhDOztJQUM3QixNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUN4QyxNQUFNTyx1QkFBdUJQLDZDQUFNQSxDQUdoQztRQUFFUSxVQUFVO1FBQU1DLFdBQVc7SUFBSztJQUVyQyxNQUFNQyxzQkFBc0JWLDZDQUFNQSxDQUcvQjtRQUFFVyxnQkFBZ0I7UUFBR0MsaUJBQWlCO0lBQUU7SUFFM0NiLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDTSxVQUFVUSxPQUFPLEVBQUU7UUFFeEIsTUFBTUMsU0FBUyxDQUFDQztZQUNkLElBQUlDO1lBQ0osSUFBSUMsYUFBYTtZQUNqQixJQUFJQyxpQkFBaUI7WUFDckIsSUFBSUMsbUJBQW1CO1lBQ3ZCLElBQUlDLFdBQVc7WUFDZixJQUFJQyxTQUFTO1lBRWJOLEVBQUVPLEtBQUssR0FBRztnQkFDUk4sZUFBZUQsRUFBRVEsWUFBWSxDQUFDLEtBQUssR0FBRztnQkFDdENSLEVBQUVTLFlBQVksQ0FBQyxLQUFLLEtBQUtULEVBQUVVLEtBQUs7Z0JBQ2hDVixFQUFFVyxTQUFTLENBQUMsS0FBSyxxQ0FBcUM7Z0JBRXRELGlEQUFpRDtnQkFDakQsSUFBSTtvQkFDRlgsRUFBRVksUUFBUSxDQUFDO2dCQUNiLEVBQUUsT0FBT0MsT0FBTztvQkFDZEMsUUFBUUMsSUFBSSxDQUFDLHVDQUF1Q0Y7b0JBQ3BELDJCQUEyQjtvQkFDM0JiLEVBQUVZLFFBQVEsQ0FBQztnQkFDYjtnQkFDQVosRUFBRWdCLFFBQVEsQ0FBQztZQUNiO1lBRUFoQixFQUFFaUIsSUFBSSxHQUFHO2dCQUNQakIsRUFBRWtCLEtBQUs7Z0JBQ1BsQixFQUFF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RyxLQUFLLEdBQUc7Z0JBQ2xCL0IsRUFBRThFLFNBQVMsQ0FBQzlFLEVBQUVvRixLQUFLO2dCQUNuQnBGLEVBQUVnQixRQUFRLENBQUM7Z0JBRVgsNkNBQTZDO2dCQUM3Q2hCLEVBQUVpRixJQUFJLENBQUMsb0NBQW9DakYsRUFBRTZDLEtBQUssR0FBQyxJQUFJLElBQUksQ0FBQzdDLEVBQUU4QyxNQUFNLEdBQUMsSUFBSTtnQkFFekU5QyxFQUFFcUIsR0FBRztZQUNQO1FBQ0Y7UUFFQTlCLGNBQWNPLE9BQU8sR0FBRyxJQUFJWiwyQ0FBRUEsQ0FBQ2EsUUFBUVQsVUFBVVEsT0FBTztRQUV4RCxPQUFPO1lBQ0wsSUFBSVAsY0FBY08sT0FBTyxFQUFFO2dCQUN6QlAsY0FBY08sT0FBTyxDQUFDdUYsTUFBTTtnQkFDNUI5RixjQUFjTyxPQUFPLEdBQUc7WUFDMUI7UUFDRjtJQUNGLEdBQUc7UUFBQ1Y7S0FBYztJQUVsQixxQkFBTyw4REFBQ2tHO1FBQUlDLEtBQUtqRzs7Ozs7O0FBQ25CO0dBaFl3Qkg7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvU2tldGNoLnRzeD8zNzRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgcDUgZnJvbSAncDUnO1xuaW1wb3J0IHsgTXVsdGlIYW5kRGF0YSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5pbnRlcmZhY2UgU2tldGNoUHJvcHMge1xuICBtdWx0aUhhbmREYXRhOiBNdWx0aUhhbmREYXRhO1xuICB2aWRlb1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxWaWRlb0VsZW1lbnQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTa2V0Y2goeyBtdWx0aUhhbmREYXRhLCB2aWRlb1JlZiB9OiBTa2V0Y2hQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBwNUluc3RhbmNlUmVmID0gdXNlUmVmPHA1IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHNtb290aGVkTGFuZG1hcmtzUmVmID0gdXNlUmVmPHtcbiAgICBsZWZ0SGFuZDogYW55W10gfCBudWxsO1xuICAgIHJpZ2h0SGFuZDogYW55W10gfCBudWxsO1xuICB9Pih7IGxlZnRIYW5kOiBudWxsLCByaWdodEhhbmQ6IG51bGwgfSk7XG4gIFxuICBjb25zdCBmcmFtZVBlcnNpc3RlbmNlUmVmID0gdXNlUmVmPHtcbiAgICBsZWZ0SGFuZEZyYW1lczogbnVtYmVyO1xuICAgIHJpZ2h0SGFuZEZyYW1lczogbnVtYmVyO1xuICB9Pih7IGxlZnRIYW5kRnJhbWVzOiAwLCByaWdodEhhbmRGcmFtZXM6IDAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBza2V0Y2ggPSAocDogcDUpID0+IHtcbiAgICAgIGxldCBvYmplY3RWZWN0b3I6IHA1LlZlY3RvcjtcbiAgICAgIGxldCBvYmplY3RTaXplID0gMTtcbiAgICAgIGxldCBsYXN0T2JqZWN0U2l6ZSA9IDE7XG4gICAgICBsZXQgb2JqZWN0U2l6ZVNtb290aCA9IDA7XG4gICAgICBsZXQgZ3JhYmJpbmcgPSBmYWxzZTtcbiAgICAgIGxldCBsb2NrZWQgPSBmYWxzZTtcblxuICAgICAgcC5zZXR1cCA9ICgpID0+IHtcbiAgICAgICAgb2JqZWN0VmVjdG9yID0gcC5jcmVhdGVWZWN0b3IoMTAwLCAwLCAwKTtcbiAgICAgICAgcC5jcmVhdGVDYW52YXMoODAwLCA2NDAsIHAuV0VCR0wpO1xuICAgICAgICBwLmZyYW1lUmF0ZSg2MCk7IC8vIFNldCB0byA2MCBGUFMgZm9yIHNtb290aCByZW5kZXJpbmdcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBzeXN0ZW0gZm9udCBpbnN0ZWFkIG9mIGxvYWRpbmcgY3VzdG9tIGZvbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwLnRleHRGb250KCdzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIHNhbnMtc2VyaWYnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgbG9hZGluZyBmYWlsZWQsIHVzaW5nIGRlZmF1bHQ6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgZm9udFxuICAgICAgICAgIHAudGV4dEZvbnQoJ0FyaWFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcC50ZXh0U2l6ZSgxMik7XG4gICAgICB9O1xuXG4gICAgICBwLmRyYXcgPSAoKSA9PiB7XG4gICAgICAgIHAuY2xlYXIoKTtcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAudHJhbnNsYXRlKDAsIDAsIC0xMDApO1xuICAgICAgICBwLnBvcCgpO1xuXG4gICAgICAgIC8vIEVuaGFuY2VkIGdlc3R1cmUgZGlzcGxheVxuICAgICAgICBwLnN0cm9rZVdlaWdodCg1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbG9yIGJhc2VkIG9uIGdlc3R1cmUgdHlwZSAodXNpbmcgcHJpbWFyeSBoYW5kKVxuICAgICAgICBsZXQgZ2VzdHVyZUNvbG9yO1xuICAgICAgICBjb25zdCBwcmltYXJ5SGFuZCA9IG11bHRpSGFuZERhdGEubGVmdEhhbmQgfHwgbXVsdGlIYW5kRGF0YS5yaWdodEhhbmQ7XG4gICAgICAgIFxuICAgICAgICBpZiAocHJpbWFyeUhhbmQpIHtcbiAgICAgICAgICBzd2l0Y2gocHJpbWFyeUhhbmQuZ2VzdHVyZSkge1xuICAgICAgICAgICAgY2FzZSBcInBpbmNoXCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMjU1LCAwLCAwKTsgLy8gUmVkXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZpc3RcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigyNTUsIDE2NSwgMCk7IC8vIE9yYW5nZVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuSGFuZFwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDAsIDI1NSwgMCk7IC8vIEdyZWVuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvaW50aW5nXCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMCwgMjU1LCAyNTUpOyAvLyBDeWFuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInZpY3RvcnlcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigyNTUsIDAsIDI1NSk7IC8vIE1hZ2VudGFcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDEyOCwgMTI4LCAxMjgpOyAvLyBHcmF5XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMTI4LCAxMjgsIDEyOCk7IC8vIEdyYXlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5zdHJva2UoZ2VzdHVyZUNvbG9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgZ2VzdHVyZSBpbmRpY2F0b3IgbGluZVxuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gcHJpbWFyeUhhbmQgPyBwcmltYXJ5SGFuZC5jb25maWRlbmNlICogMzAwIDogMDtcbiAgICAgICAgcC5saW5lKDAsIDAsIGxpbmVMZW5ndGgsIDApO1xuXG4gICAgICAgIC8vIERyYXcgb2JqZWN0IHdoaWNoIGlzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAuZmlsbCgwLCAwLCAyNTUsIDEwMCk7XG4gICAgICAgIHAuc3Ryb2tlKDAsIDAsIDI1NSk7XG4gICAgICAgIHAudHJhbnNsYXRlKG9iamVjdFZlY3Rvci54LCBvYmplY3RWZWN0b3IueSwgb2JqZWN0VmVjdG9yLnopO1xuICAgICAgICBwLmVsbGlwc2UoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEwMCAqIHAubWFwKG9iamVjdFZlY3Rvci56LCAwLjEsIC0wLjEsIDAuMSwgb2JqZWN0U2l6ZVNtb290aCksXG4gICAgICAgICAgMTAwICogcC5tYXAob2JqZWN0VmVjdG9yLnosIDAuMSwgLTAuMSwgMC4xLCBvYmplY3RTaXplU21vb3RoKVxuICAgICAgICApO1xuICAgICAgICBwLnBvcCgpO1xuXG4gICAgICAgIC8vIERyYXcgbGFuZG1hcmtzXG4gICAgICAgIGRpc3BsYXlSZXN1bHRzKHApO1xuXG4gICAgICAgIC8vIEVuaGFuY2VkIGdlc3R1cmUtYmFzZWQgaW50ZXJhY3Rpb25cbiAgICAgICAgaWYgKHByaW1hcnlIYW5kPy5nZXN0dXJlID09PSBcInBpbmNoXCIpIHtcbiAgICAgICAgICBncmFiYmluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBncmFiYmluZyBpbnRlcmFjdGlvbiB3aXRoIHRoZSBvYmplY3RcbiAgICAgICAgaWYgKGdyYWJiaW5nICYmIHByaW1hcnlIYW5kKSB7XG4gICAgICAgICAgLy8gVXNlIHRodW1iIHRpcCAoNCkgYW5kIGluZGV4IHRpcCAoOCkgZm9yIHBpbmNoIHBvc2l0aW9uXG4gICAgICAgICAgY29uc3QgdGh1bWJUaXAgPSBwcmltYXJ5SGFuZC5sYW5kbWFya3NbNF07XG4gICAgICAgICAgY29uc3QgaW5kZXhUaXAgPSBwcmltYXJ5SGFuZC5sYW5kbWFya3NbOF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHBpbmNoIGNlbnRlciBwb3NpdGlvblxuICAgICAgICAgIGNvbnN0IHBpbmNoWCA9ICh0aHVtYlRpcC54ICsgaW5kZXhUaXAueCkgLyAyO1xuICAgICAgICAgIGNvbnN0IHBpbmNoWSA9ICh0aHVtYlRpcC55ICsgaW5kZXhUaXAueSkgLyAyO1xuICAgICAgICAgIGNvbnN0IHBpbmNoWiA9ICh0aHVtYlRpcC56ICsgaW5kZXhUaXAueikgLyAyO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1hcCB0byB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgIGxldCBwaW5jaFZlY3RvciA9IHAuY3JlYXRlVmVjdG9yKFxuICAgICAgICAgICAgcGluY2hYICogcC53aWR0aCAtIHAud2lkdGggLyAyLFxuICAgICAgICAgICAgcGluY2hZICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDIsXG4gICAgICAgICAgICBwaW5jaFpcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHAuZGlzdChwaW5jaFZlY3Rvci54LCBwaW5jaFZlY3Rvci55LCBvYmplY3RWZWN0b3IueCwgb2JqZWN0VmVjdG9yLnkpIDwgNTAgJiZcbiAgICAgICAgICAgIGxvY2tlZCA9PSBmYWxzZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iamVjdFNpemUgPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICBvYmplY3RWZWN0b3IueCA9IHBpbmNoVmVjdG9yLng7XG4gICAgICAgICAgICBvYmplY3RWZWN0b3IueSA9IHBpbmNoVmVjdG9yLnk7XG4gICAgICAgICAgICBvYmplY3RWZWN0b3IueiA9IHBpbmNoVmVjdG9yLno7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIG9iamVjdFNpemUgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU21vb3RoIG9iamVjdCBzaXplXG4gICAgICAgIG9iamVjdFNpemVTbW9vdGggPSBvYmplY3RTaXplICogMC41ICsgbGFzdE9iamVjdFNpemUgKiAwLjU7XG4gICAgICAgIGxhc3RPYmplY3RTaXplID0gb2JqZWN0U2l6ZVNtb290aDtcblxuICAgICAgICAvLyBEcmF3IHByaXZhY3kgaW5kaWNhdG9yIG9ubHlcbiAgICAgICAgZHJhd1ByaXZhY3lJbmRpY2F0b3IocCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBTaW1wbGUgYW5kIHN0YWJsZSBsYW5kbWFyayBwcm9jZXNzaW5nIChiYXNlZCBvbiByZWZlcmVuY2UgY29kZSlcbiAgICAgIGNvbnN0IHByb2Nlc3NMYW5kbWFya3MgPSAobGFuZG1hcmtzOiBhbnlbXSkgPT4ge1xuICAgICAgICBpZiAoIWxhbmRtYXJrcyB8fCBsYW5kbWFya3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXBsZSBtYXBwaW5nIHdpdGhvdXQgY29tcGxleCBzbW9vdGhpbmdcbiAgICAgICAgcmV0dXJuIGxhbmRtYXJrcy5tYXAobGFuZG1hcmsgPT4gKHtcbiAgICAgICAgICB4OiBsYW5kbWFyay54LFxuICAgICAgICAgIHk6IGxhbmRtYXJrLnksXG4gICAgICAgICAgejogbGFuZG1hcmsuelxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBkaXNwbGF5UmVzdWx0cyhwOiBwNSkge1xuICAgICAgICAvLyBTbW9vdGggbGVmdCBoYW5kIGxhbmRtYXJrcyB3aXRoIHBlcnNpc3RlbmNlXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLmxlZnRIYW5kKSB7XG4gICAgICAgICAgY29uc3Qgc21vb3RoZWRMZWZ0ID0gc21vb3RoTGFuZG1hcmtzKFxuICAgICAgICAgICAgbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5sYW5kbWFya3MsIFxuICAgICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZCA9IHNtb290aGVkTGVmdDtcbiAgICAgICAgICBmcmFtZVBlcnNpc3RlbmNlUmVmLmN1cnJlbnQubGVmdEhhbmRGcmFtZXMgPSAwOyAvLyBSZXNldCBjb3VudGVyXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNtb290aGVkTGVmdCkge1xuICAgICAgICAgICAgLy8gRHJhdyBsZWZ0IGhhbmQgbGFuZG1hcmtzIChncmVlbilcbiAgICAgICAgICAgIHAuc3Ryb2tlKDAsIDI1NSwgMCk7IC8vIEdyZWVuIGZvciBsZWZ0IGhhbmRcbiAgICAgICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDQpO1xuICAgICAgICAgICAgcC5maWxsKDAsIDI1NSwgMCwgMTAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyBjb25uZWN0aW9ucyBiZXR3ZWVuIGxhbmRtYXJrcyBmb3IgYmV0dGVyIHZpc3VhbGl6YXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc21vb3RoZWRMZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gc21vb3RoZWRMZWZ0W2ldO1xuICAgICAgICAgICAgICBjb25zdCB4ID0gbGFuZG1hcmsueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeSA9IGxhbmRtYXJrLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBEcmF3IGxhbmRtYXJrIHBvaW50XG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5zcGhlcmUoMyk7XG4gICAgICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgaGFuZCBjb25uZWN0aW9ucyAoZmluZ2VyIGJvbmVzKVxuICAgICAgICAgICAgZHJhd0hhbmRDb25uZWN0aW9ucyhwLCBzbW9vdGhlZExlZnQsIDAsIDI1NSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEtlZXAgcHJldmlvdXMgbGFuZG1hcmtzIGZvciBzZXZlcmFsIGZyYW1lcyB0byBwcmV2ZW50IGZsYXNoaW5nXG4gICAgICAgICAgZnJhbWVQZXJzaXN0ZW5jZVJlZi5jdXJyZW50LmxlZnRIYW5kRnJhbWVzKys7XG4gICAgICAgICAgY29uc3QgbWF4UGVyc2lzdGVuY2VGcmFtZXMgPSAxMDsgLy8gS2VlcCBmb3IgMTAgZnJhbWVzXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQubGVmdEhhbmQgJiYgZnJhbWVQZXJzaXN0ZW5jZVJlZi5jdXJyZW50LmxlZnRIYW5kRnJhbWVzIDwgbWF4UGVyc2lzdGVuY2VGcmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMZWZ0ID0gc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5sZWZ0SGFuZDtcbiAgICAgICAgICAgIGNvbnN0IGZhZGVBbHBoYSA9IE1hdGgubWF4KDAsIDI1NSAtIChmcmFtZVBlcnNpc3RlbmNlUmVmLmN1cnJlbnQubGVmdEhhbmRGcmFtZXMgKiAyNSkpOyAvLyBHcmFkdWFsIGZhZGVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcC5zdHJva2UoMCwgMjU1LCAwLCBmYWRlQWxwaGEpO1xuICAgICAgICAgICAgcC5zdHJva2VXZWlnaHQoMik7XG4gICAgICAgICAgICBwLmZpbGwoMCwgMjU1LCAwLCBmYWRlQWxwaGEgKiAwLjMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RMZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gbGFzdExlZnRbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHggPSBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgICBjb25zdCB5ID0gbGFuZG1hcmsueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBjb25zdCB6ID0gbGFuZG1hcmsuejtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5zcGhlcmUoMik7XG4gICAgICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZVBlcnNpc3RlbmNlUmVmLmN1cnJlbnQubGVmdEhhbmRGcmFtZXMgPj0gbWF4UGVyc2lzdGVuY2VGcmFtZXMpIHtcbiAgICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQubGVmdEhhbmQgPSBudWxsOyAvLyBDbGVhciBhZnRlciBwZXJzaXN0ZW5jZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU21vb3RoIHJpZ2h0IGhhbmQgbGFuZG1hcmtzIHdpdGggcGVyc2lzdGVuY2VcbiAgICAgICAgaWYgKG11bHRpSGFuZERhdGEucmlnaHRIYW5kKSB7XG4gICAgICAgICAgY29uc3Qgc21vb3RoZWRSaWdodCA9IHNtb290aExhbmRtYXJrcyhcbiAgICAgICAgICAgIG11bHRpSGFuZERhdGEucmlnaHRIYW5kLmxhbmRtYXJrcywgXG4gICAgICAgICAgICBzbW9vdGhlZExhbmRtYXJrc1JlZi5jdXJyZW50LnJpZ2h0SGFuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5yaWdodEhhbmQgPSBzbW9vdGhlZFJpZ2h0O1xuICAgICAgICAgIGZyYW1lUGVyc2lzdGVuY2VSZWYuY3VycmVudC5yaWdodEhhbmRGcmFtZXMgPSAwOyAvLyBSZXNldCBjb3VudGVyXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNtb290aGVkUmlnaHQpIHtcbiAgICAgICAgICAgIC8vIERyYXcgcmlnaHQgaGFuZCBsYW5kbWFya3MgKGJsdWUpXG4gICAgICAgICAgICBwLnN0cm9rZSgwLCAwLCAyNTUpOyAvLyBCbHVlIGZvciByaWdodCBoYW5kXG4gICAgICAgICAgICBwLnN0cm9rZVdlaWdodCg0KTtcbiAgICAgICAgICAgIHAuZmlsbCgwLCAwLCAyNTUsIDEwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgY29ubmVjdGlvbnMgYmV0d2VlbiBsYW5kbWFya3MgZm9yIGJldHRlciB2aXN1YWxpemF0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtb290aGVkUmlnaHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBzbW9vdGhlZFJpZ2h0W2ldO1xuICAgICAgICAgICAgICBjb25zdCB4ID0gbGFuZG1hcmsueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeSA9IGxhbmRtYXJrLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBEcmF3IGxhbmRtYXJrIHBvaW50XG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5zcGhlcmUoMyk7XG4gICAgICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgaGFuZCBjb25uZWN0aW9ucyAoZmluZ2VyIGJvbmVzKVxuICAgICAgICAgICAgZHJhd0hhbmRDb25uZWN0aW9ucyhwLCBzbW9vdGhlZFJpZ2h0LCAwLCAwLCAyNTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBLZWVwIHByZXZpb3VzIGxhbmRtYXJrcyBmb3Igc2V2ZXJhbCBmcmFtZXMgdG8gcHJldmVudCBmbGFzaGluZ1xuICAgICAgICAgIGZyYW1lUGVyc2lzdGVuY2VSZWYuY3VycmVudC5yaWdodEhhbmRGcmFtZXMrKztcbiAgICAgICAgICBjb25zdCBtYXhQZXJzaXN0ZW5jZUZyYW1lcyA9IDEwOyAvLyBLZWVwIGZvciAxMCBmcmFtZXNcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5yaWdodEhhbmQgJiYgZnJhbWVQZXJzaXN0ZW5jZVJlZi5jdXJyZW50LnJpZ2h0SGFuZEZyYW1lcyA8IG1heFBlcnNpc3RlbmNlRnJhbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UmlnaHQgPSBzbW9vdGhlZExhbmRtYXJrc1JlZi5jdXJyZW50LnJpZ2h0SGFuZDtcbiAgICAgICAgICAgIGNvbnN0IGZhZGVBbHBoYSA9IE1hdGgubWF4KDAsIDI1NSAtIChmcmFtZVBlcnNpc3RlbmNlUmVmLmN1cnJlbnQucmlnaHRIYW5kRnJhbWVzICogMjUpKTsgLy8gR3JhZHVhbCBmYWRlXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHAuc3Ryb2tlKDAsIDAsIDI1NSwgZmFkZUFscGhhKTtcbiAgICAgICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDIpO1xuICAgICAgICAgICAgcC5maWxsKDAsIDAsIDI1NSwgZmFkZUFscGhhICogMC4zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0UmlnaHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYXN0UmlnaHRbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHggPSBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgICBjb25zdCB5ID0gbGFuZG1hcmsueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBjb25zdCB6ID0gbGFuZG1hcmsuejtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgcC5zcGhlcmUoMik7XG4gICAgICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZVBlcnNpc3RlbmNlUmVmLmN1cnJlbnQucmlnaHRIYW5kRnJhbWVzID49IG1heFBlcnNpc3RlbmNlRnJhbWVzKSB7XG4gICAgICAgICAgICBzbW9vdGhlZExhbmRtYXJrc1JlZi5jdXJyZW50LnJpZ2h0SGFuZCA9IG51bGw7IC8vIENsZWFyIGFmdGVyIHBlcnNpc3RlbmNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdIYW5kQ29ubmVjdGlvbnMocDogcDUsIGxhbmRtYXJrczogYW55W10sIHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICAgICAgLy8gTWVkaWFQaXBlIGhhbmQgY29ubmVjdGlvbnMgKGZpbmdlciBib25lcylcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBbXG4gICAgICAgICAgLy8gVGh1bWJcbiAgICAgICAgICBbMCwgMV0sIFsxLCAyXSwgWzIsIDNdLCBbMywgNF0sXG4gICAgICAgICAgLy8gSW5kZXggZmluZ2VyXG4gICAgICAgICAgWzAsIDVdLCBbNSwgNl0sIFs2LCA3XSwgWzcsIDhdLFxuICAgICAgICAgIC8vIE1pZGRsZSBmaW5nZXJcbiAgICAgICAgICBbMCwgOV0sIFs5LCAxMF0sIFsxMCwgMTFdLCBbMTEsIDEyXSxcbiAgICAgICAgICAvLyBSaW5nIGZpbmdlclxuICAgICAgICAgIFswLCAxM10sIFsxMywgMTRdLCBbMTQsIDE1XSwgWzE1LCAxNl0sXG4gICAgICAgICAgLy8gUGlua3lcbiAgICAgICAgICBbMCwgMTddLCBbMTcsIDE4XSwgWzE4LCAxOV0sIFsxOSwgMjBdLFxuICAgICAgICAgIC8vIFBhbG0gY29ubmVjdGlvbnNcbiAgICAgICAgICBbNSwgOV0sIFs5LCAxM10sIFsxMywgMTddXG4gICAgICAgIF07XG5cbiAgICAgICAgcC5zdHJva2UociwgZywgYiwgMTUwKTtcbiAgICAgICAgcC5zdHJva2VXZWlnaHQoMik7XG4gICAgICAgIHAubm9GaWxsKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2YgY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICBpZiAobGFuZG1hcmtzW3N0YXJ0XSAmJiBsYW5kbWFya3NbZW5kXSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gbGFuZG1hcmtzW3N0YXJ0XS54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gbGFuZG1hcmtzW3N0YXJ0XS55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFogPSBsYW5kbWFya3Nbc3RhcnRdLno7XG4gICAgICAgICAgICBjb25zdCBlbmRYID0gbGFuZG1hcmtzW2VuZF0ueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGVuZFkgPSBsYW5kbWFya3NbZW5kXS55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCBlbmRaID0gbGFuZG1hcmtzW2VuZF0uejtcblxuICAgICAgICAgICAgcC5saW5lKHN0YXJ0WCwgc3RhcnRZLCBzdGFydFosIGVuZFgsIGVuZFksIGVuZFopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3R2VzdHVyZURlYnVnKHA6IHA1KSB7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLmZpbGwoMjU1KTtcbiAgICAgICAgcC50ZXh0QWxpZ24ocC5MRUZUKTtcbiAgICAgICAgcC50ZXh0U2l6ZSgxNCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgeVBvcyA9IC1wLmhlaWdodC8yICsgMjA7XG4gICAgICAgIHAudGV4dChcIk11bHRpLUhhbmQgR2VzdHVyZSBEZWJ1ZzpcIiwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAyMDtcbiAgICAgICAgXG4gICAgICAgIC8vIExlZnQgaGFuZCBpbmZvXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLmxlZnRIYW5kKSB7XG4gICAgICAgICAgcC50ZXh0KGBMZWZ0IEhhbmQ6ICR7bXVsdGlIYW5kRGF0YS5sZWZ0SGFuZC5nZXN0dXJlfSAoJHtNYXRoLnJvdW5kKG11bHRpSGFuZERhdGEubGVmdEhhbmQuY29uZmlkZW5jZSAqIDEwMCl9JSlgLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50ZXh0KFwiTGVmdCBIYW5kOiBOb3QgZGV0ZWN0ZWRcIiwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodCBoYW5kIGluZm9cbiAgICAgICAgaWYgKG11bHRpSGFuZERhdGEucmlnaHRIYW5kKSB7XG4gICAgICAgICAgcC50ZXh0KGBSaWdodCBIYW5kOiAke211bHRpSGFuZERhdGEucmlnaHRIYW5kLmdlc3R1cmV9ICgke01hdGgucm91bmQobXVsdGlIYW5kRGF0YS5yaWdodEhhbmQuY29uZmlkZW5jZSAqIDEwMCl9JSlgLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50ZXh0KFwiUmlnaHQgSGFuZDogTm90IGRldGVjdGVkXCIsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29tYmluZWQgaW5mb1xuICAgICAgICB5UG9zICs9IDEwO1xuICAgICAgICBjb25zdCBwcmltYXJ5SGFuZCA9IG11bHRpSGFuZERhdGEubGVmdEhhbmQgfHwgbXVsdGlIYW5kRGF0YS5yaWdodEhhbmQ7XG4gICAgICAgIHAudGV4dChgUHJpbWFyeTogJHtwcmltYXJ5SGFuZD8uZ2VzdHVyZSB8fCAnTm9uZSd9YCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgcC50ZXh0KGBDb25maWRlbmNlOiAke01hdGgucm91bmQoKHByaW1hcnlIYW5kPy5jb25maWRlbmNlIHx8IDApICogMTAwKX0lYCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgcC50ZXh0KGBIYW5kcyBEZXRlY3RlZDogJHttdWx0aUhhbmREYXRhLnRvdGFsSGFuZHN9YCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdQcml2YWN5SW5kaWNhdG9yKHA6IHA1KSB7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLmZpbGwoMCwgMjU1LCAwLCAxNTApO1xuICAgICAgICBwLnRleHRBbGlnbihwLlJJR0hUKTtcbiAgICAgICAgcC50ZXh0U2l6ZSgxMik7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHByaXZhY3kgaW5kaWNhdG9yIGluIHRvcC1yaWdodCBjb3JuZXJcbiAgICAgICAgcC50ZXh0KFwiUHJpdmFjeSBNb2RlOiBIYW5kIFRyYWNraW5nIE9ubHlcIiwgcC53aWR0aC8yIC0gMTAsIC1wLmhlaWdodC8yICsgMjApO1xuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50ID0gbmV3IHA1KHNrZXRjaCwgY2FudmFzUmVmLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwNUluc3RhbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFttdWx0aUhhbmREYXRhXSk7XG5cbiAgcmV0dXJuIDxkaXYgcmVmPXtjYW52YXNSZWZ9IC8+O1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwicDUiLCJTa2V0Y2giLCJtdWx0aUhhbmREYXRhIiwidmlkZW9SZWYiLCJjYW52YXNSZWYiLCJwNUluc3RhbmNlUmVmIiwic21vb3RoZWRMYW5kbWFya3NSZWYiLCJsZWZ0SGFuZCIsInJpZ2h0SGFuZCIsImZyYW1lUGVyc2lzdGVuY2VSZWYiLCJsZWZ0SGFuZEZyYW1lcyIsInJpZ2h0SGFuZEZyYW1lcyIsImN1cnJlbnQiLCJza2V0Y2giLCJwIiwib2JqZWN0VmVjdG9yIiwib2JqZWN0U2l6ZSIsImxhc3RPYmplY3RTaXplIiwib2JqZWN0U2l6ZVNtb290aCIsImdyYWJiaW5nIiwibG9ja2VkIiwic2V0dXAiLCJjcmVhdGVWZWN0b3IiLCJjcmVhdGVDYW52YXMiLCJXRUJHTCIsImZyYW1lUmF0ZSIsInRleHRGb250IiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsInRleHRTaXplIiwiZHJhdyIsImNsZWFyIiwicHVzaCIsInRyYW5zbGF0ZSIsInBvcCIsInN0cm9rZVdlaWdodCIsImdlc3R1cmVDb2xvciIsInByaW1hcnlIYW5kIiwiZ2VzdHVyZSIsImNvbG9yIiwic3Ryb2tlIiwibGluZUxlbmd0aCIsImNvbmZpZGVuY2UiLCJsaW5lIiwiZmlsbCIsIngiLCJ5IiwieiIsImVsbGlwc2UiLCJtYXAiLCJkaXNwbGF5UmVzdWx0cyIsInRodW1iVGlwIiwibGFuZG1hcmtzIiwiaW5kZXhUaXAiLCJwaW5jaFgiLCJwaW5jaFkiLCJwaW5jaFoiLCJwaW5jaFZlY3RvciIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzdCIsImRyYXdQcml2YWN5SW5kaWNhdG9yIiwicHJvY2Vzc0xhbmRtYXJrcyIsImxlbmd0aCIsImxhbmRtYXJrIiwic21vb3RoZWRMZWZ0Iiwic21vb3RoTGFuZG1hcmtzIiwiaSIsInNwaGVyZSIsImRyYXdIYW5kQ29ubmVjdGlvbnMiLCJtYXhQZXJzaXN0ZW5jZUZyYW1lcyIsImxhc3RMZWZ0IiwiZmFkZUFscGhhIiwiTWF0aCIsIm1heCIsInNtb290aGVkUmlnaHQiLCJsYXN0UmlnaHQiLCJyIiwiZyIsImIiLCJjb25uZWN0aW9ucyIsIm5vRmlsbCIsInN0YXJ0IiwiZW5kIiwic3RhcnRYIiwic3RhcnRZIiwic3RhcnRaIiwiZW5kWCIsImVuZFkiLCJlbmRaIiwiZHJhd0dlc3R1cmVEZWJ1ZyIsInRleHRBbGlnbiIsIkxFRlQiLCJ5UG9zIiwidGV4dCIsInJvdW5kIiwidG90YWxIYW5kcyIsIlJJR0hUIiwicmVtb3ZlIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Sketch.tsx\n"));

/***/ })

});
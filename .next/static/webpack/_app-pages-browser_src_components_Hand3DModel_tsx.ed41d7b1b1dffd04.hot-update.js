"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Hand3DModel_tsx",{

/***/ "(app-pages-browser)/./src/components/Hand3DModel.tsx":
/*!****************************************!*\
  !*** ./src/components/Hand3DModel.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Hand3DModel; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Hand3DModel(param) {\n    let { leftHand, rightHand } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Smoothing and stabilization refs\n    const previousLeftHand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const previousRightHand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const velocityLeft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const velocityRight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const frameCount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let handTexture;\n            p.preload = ()=>{\n                // Create a realistic hand texture programmatically\n                handTexture = p.createImage(128, 128);\n                handTexture.loadPixels();\n                for(let y = 0; y < handTexture.height; y++){\n                    for(let x = 0; x < handTexture.width; x++){\n                        const index = (y * handTexture.width + x) * 4;\n                        // Create skin-like color with variation\n                        const baseR = 255;\n                        const baseG = 200 + Math.sin(x * 0.1) * 20;\n                        const baseB = 150 + Math.cos(y * 0.1) * 15;\n                        // Add some texture variation\n                        const noise = Math.sin(x * 0.05) * Math.cos(y * 0.05) * 10;\n                        handTexture.pixels[index] = Math.max(200, Math.min(255, baseR + noise)); // R\n                        handTexture.pixels[index + 1] = Math.max(180, Math.min(220, baseG + noise)); // G\n                        handTexture.pixels[index + 2] = Math.max(140, Math.min(170, baseB + noise)); // B\n                        handTexture.pixels[index + 3] = 255; // A\n                    }\n                }\n                handTexture.updatePixels();\n            };\n            p.setup = ()=>{\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(60);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                // Set up lighting\n                p.ambientLight(60, 60, 60);\n                p.directionalLight(255, 255, 255, 0, 0, -1);\n                p.pointLight(255, 255, 255, 0, 0, 0);\n                // Apply smoothing to landmarks\n                let smoothedLeftLandmarks = null;\n                let smoothedRightLandmarks = null;\n                if (leftHand) {\n                    smoothedLeftLandmarks = smoothLandmarks(leftHand.landmarks, previousLeftHand.current, velocityLeft.current, 0.25);\n                    previousLeftHand.current = smoothedLeftLandmarks;\n                }\n                if (rightHand) {\n                    smoothedRightLandmarks = smoothLandmarks(rightHand.landmarks, previousRightHand.current, velocityRight.current, 0.25);\n                    previousRightHand.current = smoothedRightLandmarks;\n                }\n                // Render left hand with smoothed landmarks\n                if (smoothedLeftLandmarks) {\n                    renderHand3D(p, smoothedLeftLandmarks, [\n                        0,\n                        255,\n                        0\n                    ], \"left\");\n                }\n                // Render right hand with smoothed landmarks\n                if (smoothedRightLandmarks) {\n                    renderHand3D(p, smoothedRightLandmarks, [\n                        0,\n                        0,\n                        255\n                    ], \"right\");\n                }\n                p.pop();\n            };\n            const renderHand3D = (p, landmarks, color, handType)=>{\n                if (!landmarks || landmarks.length < 21) return;\n                p.push();\n                // Calculate hand center and orientation\n                const handCenter = calculateHandCenter(landmarks);\n                const handRotation = calculateHandRotation(landmarks);\n                const handScale = calculateHandScale(landmarks);\n                // Transform to hand position with stable coordinate mapping\n                const screenX = -handCenter.x * p.width + p.width / 2;\n                const screenY = handCenter.y * p.height - p.height / 2;\n                const screenZ = handCenter.z * 50; // Reduced depth for stability\n                p.translate(screenX, screenY, screenZ);\n                p.rotateX(handRotation.x);\n                p.rotateY(handRotation.y);\n                p.rotateZ(handRotation.z);\n                p.scale(handScale);\n                // Render palm with texture\n                renderPalm(p, landmarks, color);\n                // Render fingers with texture\n                renderFingers(p, landmarks, color);\n                p.pop();\n            };\n            const calculateHandCenter = (landmarks)=>{\n                // Use wrist (landmark 0) as center\n                return {\n                    x: landmarks[0].x,\n                    y: landmarks[0].y,\n                    z: landmarks[0].z\n                };\n            };\n            const calculateHandRotation = (landmarks)=>{\n                // Calculate hand orientation based on palm landmarks\n                const wrist = landmarks[0];\n                const middleFinger = landmarks[12];\n                const indexFinger = landmarks[8];\n                // Calculate palm normal\n                const palmNormal = p.createVector(middleFinger.x - wrist.x, middleFinger.y - wrist.y, middleFinger.z - wrist.z);\n                return {\n                    x: Math.atan2(palmNormal.y, palmNormal.z),\n                    y: Math.atan2(palmNormal.x, palmNormal.z),\n                    z: Math.atan2(palmNormal.y, palmNormal.x)\n                };\n            };\n            const calculateHandScale = (landmarks)=>{\n                // Calculate hand size based on palm width\n                const wrist = landmarks[0];\n                const pinky = landmarks[17];\n                const thumb = landmarks[4];\n                const palmWidth = Math.abs(pinky.x - thumb.x);\n                return Math.max(0.5, Math.min(2.0, palmWidth * 10));\n            };\n            const renderPalm = (p, landmarks, color)=>{\n                // Create palm using textured spheres at key points\n                const palmLandmarks = [\n                    0,\n                    5,\n                    9,\n                    13,\n                    17\n                ]; // Wrist and finger bases\n                p.push();\n                p.texture(handTexture);\n                p.noStroke();\n                // Draw palm center with texture\n                const wrist = landmarks[0];\n                const palmCenter = {\n                    x: (wrist.x - 0.5) * 2,\n                    y: (wrist.y - 0.5) * 2,\n                    z: wrist.z\n                };\n                p.push();\n                p.translate(palmCenter.x, palmCenter.y, palmCenter.z);\n                p.fill(255, 200, 150, 200); // Skin color\n                p.sphere(0.08);\n                p.pop();\n                // Draw palm joints with texture\n                for(let i = 1; i < palmLandmarks.length; i++){\n                    const landmark = landmarks[palmLandmarks[i]];\n                    const x = (landmark.x - 0.5) * 2;\n                    const y = (landmark.y - 0.5) * 2;\n                    const z = landmark.z;\n                    p.push();\n                    p.translate(x, y, z);\n                    p.fill(255, 200, 150, 180); // Skin color\n                    p.sphere(0.05);\n                    p.pop();\n                }\n                // Draw palm connections with skin color\n                p.noFill();\n                p.stroke(255, 200, 150, 120);\n                p.strokeWeight(4);\n                for(let i = 0; i < palmLandmarks.length - 1; i++){\n                    const current = landmarks[palmLandmarks[i]];\n                    const next = landmarks[palmLandmarks[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n            const renderFingers = (p, landmarks, color)=>{\n                // Finger landmark indices\n                const fingerIndices = [\n                    [\n                        4,\n                        3,\n                        2,\n                        1,\n                        0\n                    ],\n                    [\n                        8,\n                        7,\n                        6,\n                        5\n                    ],\n                    [\n                        12,\n                        11,\n                        10,\n                        9\n                    ],\n                    [\n                        16,\n                        15,\n                        14,\n                        13\n                    ],\n                    [\n                        20,\n                        19,\n                        18,\n                        17\n                    ] // Pinky\n                ];\n                fingerIndices.forEach((finger, fingerIndex)=>{\n                    renderFinger(p, landmarks, finger, color, fingerIndex);\n                });\n            };\n            const renderFinger = (p, landmarks, fingerIndices, color, fingerIndex)=>{\n                p.push();\n                p.texture(handTexture);\n                // Draw finger joints as textured spheres\n                for(let i = 0; i < fingerIndices.length; i++){\n                    const landmark = landmarks[fingerIndices[i]];\n                    const x = (landmark.x - 0.5) * 2;\n                    const y = (landmark.y - 0.5) * 2;\n                    const z = landmark.z;\n                    p.push();\n                    p.translate(x, y, z);\n                    const jointSize = 0.025 * (1 - i * 0.1); // Smaller towards tip\n                    p.fill(255, 200, 150, 200); // Skin color\n                    p.sphere(jointSize);\n                    p.pop();\n                }\n                // Draw finger connections with skin color\n                p.noFill();\n                p.stroke(255, 200, 150, 150);\n                p.strokeWeight(3);\n                for(let i = 0; i < fingerIndices.length - 1; i++){\n                    const current = landmarks[fingerIndices[i]];\n                    const next = landmarks[fingerIndices[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        leftHand,\n        rightHand\n    ]);\n    // Smoothing function with velocity-based interpolation\n    const smoothLandmarks = function(currentLandmarks, previousLandmarks, velocities) {\n        let smoothingFactor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.3;\n        if (!currentLandmarks || currentLandmarks.length === 0) {\n            return previousLandmarks;\n        }\n        if (!previousLandmarks || previousLandmarks.length !== currentLandmarks.length) {\n            // Initialize velocities\n            velocities.length = currentLandmarks.length;\n            for(let i = 0; i < currentLandmarks.length; i++){\n                velocities[i] = {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                };\n            }\n            return currentLandmarks;\n        }\n        const smoothedLandmarks = [];\n        for(let i = 0; i < currentLandmarks.length; i++){\n            const current = currentLandmarks[i];\n            const previous = previousLandmarks[i];\n            const velocity = velocities[i];\n            // Calculate velocity (change in position)\n            const deltaX = current.x - previous.x;\n            const deltaY = current.y - previous.y;\n            const deltaZ = current.z - previous.z;\n            // Update velocity with smoothing\n            velocity.x = velocity.x * 0.8 + deltaX * 0.2;\n            velocity.y = velocity.y * 0.8 + deltaY * 0.2;\n            velocity.z = velocity.z * 0.8 + deltaZ * 0.2;\n            // Apply velocity-based smoothing\n            const smoothedX = previous.x + velocity.x * smoothingFactor;\n            const smoothedY = previous.y + velocity.y * smoothingFactor;\n            const smoothedZ = previous.z + velocity.z * smoothingFactor;\n            // Clamp to prevent extreme values\n            const clampedX = Math.max(0, Math.min(1, smoothedX));\n            const clampedY = Math.max(0, Math.min(1, smoothedY));\n            const clampedZ = Math.max(-1, Math.min(1, smoothedZ));\n            smoothedLandmarks.push({\n                x: clampedX,\n                y: clampedY,\n                z: clampedZ\n            });\n        }\n        return smoothedLandmarks;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Hand3DModel.tsx\",\n        lineNumber: 345,\n        columnNumber: 10\n    }, this);\n}\n_s(Hand3DModel, \"hQofq7RbjNpzPDDyEHkNZNeXNGI=\");\n_c = Hand3DModel;\nvar _c;\n$RefreshReg$(_c, \"Hand3DModel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hhbmQzRE1vZGVsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQztBQUN0QjtBQVFMLFNBQVNHLFlBQVksS0FBeUM7UUFBekMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQW9CLEdBQXpDOztJQUNsQyxNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUV4QyxtQ0FBbUM7SUFDbkMsTUFBTU8sbUJBQW1CUCw2Q0FBTUEsQ0FBZTtJQUM5QyxNQUFNUSxvQkFBb0JSLDZDQUFNQSxDQUFlO0lBQy9DLE1BQU1TLGVBQWVULDZDQUFNQSxDQUFRLEVBQUU7SUFDckMsTUFBTVUsZ0JBQWdCViw2Q0FBTUEsQ0FBUSxFQUFFO0lBQ3RDLE1BQU1XLGFBQWFYLDZDQUFNQSxDQUFDO0lBRTFCRCxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ00sVUFBVU8sT0FBTyxFQUFFO1FBRXhCLE1BQU1DLFNBQVMsQ0FBQ0M7WUFDZCxJQUFJQztZQUVKRCxFQUFFRSxPQUFPLEdBQUc7Z0JBQ1YsbURBQW1EO2dCQUNuREQsY0FBY0QsRUFBRUcsV0FBVyxDQUFDLEtBQUs7Z0JBQ2pDRixZQUFZRyxVQUFVO2dCQUV0QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosWUFBWUssTUFBTSxFQUFFRCxJQUFLO29CQUMzQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSU4sWUFBWU8sS0FBSyxFQUFFRCxJQUFLO3dCQUMxQyxNQUFNRSxRQUFRLENBQUNKLElBQUlKLFlBQVlPLEtBQUssR0FBR0QsQ0FBQUEsSUFBSzt3QkFFNUMsd0NBQXdDO3dCQUN4QyxNQUFNRyxRQUFRO3dCQUNkLE1BQU1DLFFBQVEsTUFBTUMsS0FBS0MsR0FBRyxDQUFDTixJQUFJLE9BQU87d0JBQ3hDLE1BQU1PLFFBQVEsTUFBTUYsS0FBS0csR0FBRyxDQUFDVixJQUFJLE9BQU87d0JBRXhDLDZCQUE2Qjt3QkFDN0IsTUFBTVcsUUFBUUosS0FBS0MsR0FBRyxDQUFDTixJQUFJLFFBQVFLLEtBQUtHLEdBQUcsQ0FBQ1YsSUFBSSxRQUFRO3dCQUV4REosWUFBWWdCLE1BQU0sQ0FBQ1IsTUFBTSxHQUFHRyxLQUFLTSxHQUFHLENBQUMsS0FBS04sS0FBS08sR0FBRyxDQUFDLEtBQUtULFFBQVFNLFNBQWEsSUFBSTt3QkFDakZmLFlBQVlnQixNQUFNLENBQUNSLFFBQVEsRUFBRSxHQUFHRyxLQUFLTSxHQUFHLENBQUMsS0FBS04sS0FBS08sR0FBRyxDQUFDLEtBQUtSLFFBQVFLLFNBQVMsSUFBSTt3QkFDakZmLFlBQVlnQixNQUFNLENBQUNSLFFBQVEsRUFBRSxHQUFHRyxLQUFLTSxHQUFHLENBQUMsS0FBS04sS0FBS08sR0FBRyxDQUFDLEtBQUtMLFFBQVFFLFNBQVMsSUFBSTt3QkFDakZmLFlBQVlnQixNQUFNLENBQUNSLFFBQVEsRUFBRSxHQUFHLEtBQUssSUFBSTtvQkFDM0M7Z0JBQ0Y7Z0JBQ0FSLFlBQVltQixZQUFZO1lBQzFCO1lBRUFwQixFQUFFcUIsS0FBSyxHQUFHO2dCQUNSckIsRUFBRXNCLFlBQVksQ0FBQyxLQUFLLEtBQUt0QixFQUFFdUIsS0FBSztnQkFDaEN2QixFQUFFd0IsU0FBUyxDQUFDO1lBQ2Q7WUFFQXhCLEVBQUV5QixJQUFJLEdBQUc7Z0JBQ1B6QixFQUFFMEIsS0FBSztnQkFDUDFCLEVBQUUyQixJQUFJO2dCQUNOM0IsRUFBRTRCLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFFbkIsa0JBQWtCO2dCQUNsQjVCLEVBQUU2QixZQUFZLENBQUMsSUFBSSxJQUFJO2dCQUN2QjdCLEVBQUU4QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDekM5QixFQUFFK0IsVUFBVSxDQUFDLEtBQUssS0FBSyxLQUFLLEdBQUcsR0FBRztnQkFFbEMsK0JBQStCO2dCQUMvQixJQUFJQyx3QkFBd0I7Z0JBQzVCLElBQUlDLHlCQUF5QjtnQkFFN0IsSUFBSTVDLFVBQVU7b0JBQ1oyQyx3QkFBd0JFLGdCQUFnQjdDLFNBQVM4QyxTQUFTLEVBQUUxQyxpQkFBaUJLLE9BQU8sRUFBRUgsYUFBYUcsT0FBTyxFQUFFO29CQUM1R0wsaUJBQWlCSyxPQUFPLEdBQUdrQztnQkFDN0I7Z0JBRUEsSUFBSTFDLFdBQVc7b0JBQ2IyQyx5QkFBeUJDLGdCQUFnQjVDLFVBQVU2QyxTQUFTLEVBQUV6QyxrQkFBa0JJLE9BQU8sRUFBRUYsY0FBY0UsT0FBTyxFQUFFO29CQUNoSEosa0JBQWtCSSxPQUFPLEdBQUdtQztnQkFDOUI7Z0JBRUEsMkNBQTJDO2dCQUMzQyxJQUFJRCx1QkFBdUI7b0JBQ3pCSSxhQUFhcEMsR0FBR2dDLHVCQUF1Qjt3QkFBQzt3QkFBRzt3QkFBSztxQkFBRSxFQUFFO2dCQUN0RDtnQkFFQSw0Q0FBNEM7Z0JBQzVDLElBQUlDLHdCQUF3QjtvQkFDMUJHLGFBQWFwQyxHQUFHaUMsd0JBQXdCO3dCQUFDO3dCQUFHO3dCQUFHO3FCQUFJLEVBQUU7Z0JBQ3ZEO2dCQUVBakMsRUFBRXFDLEdBQUc7WUFDUDtZQUVBLE1BQU1ELGVBQWUsQ0FBQ3BDLEdBQU9tQyxXQUFrQkcsT0FBaUJDO2dCQUM5RCxJQUFJLENBQUNKLGFBQWFBLFVBQVVLLE1BQU0sR0FBRyxJQUFJO2dCQUV6Q3hDLEVBQUUyQixJQUFJO2dCQUVOLHdDQUF3QztnQkFDeEMsTUFBTWMsYUFBYUMsb0JBQW9CUDtnQkFDdkMsTUFBTVEsZUFBZUMsc0JBQXNCVDtnQkFDM0MsTUFBTVUsWUFBWUMsbUJBQW1CWDtnQkFFckMsNERBQTREO2dCQUM1RCxNQUFNWSxVQUFVLENBQUNOLFdBQVdsQyxDQUFDLEdBQUdQLEVBQUVRLEtBQUssR0FBR1IsRUFBRVEsS0FBSyxHQUFHO2dCQUNwRCxNQUFNd0MsVUFBVVAsV0FBV3BDLENBQUMsR0FBR0wsRUFBRU0sTUFBTSxHQUFHTixFQUFFTSxNQUFNLEdBQUc7Z0JBQ3JELE1BQU0yQyxVQUFVUixXQUFXUyxDQUFDLEdBQUcsSUFBSSw4QkFBOEI7Z0JBRWpFbEQsRUFBRTRCLFNBQVMsQ0FBQ21CLFNBQVNDLFNBQVNDO2dCQUM5QmpELEVBQUVtRCxPQUFPLENBQUNSLGFBQWFwQyxDQUFDO2dCQUN4QlAsRUFBRW9ELE9BQU8sQ0FBQ1QsYUFBYXRDLENBQUM7Z0JBQ3hCTCxFQUFFcUQsT0FBTyxDQUFDVixhQUFhTyxDQUFDO2dCQUN4QmxELEVBQUVzRCxLQUFLLENBQUNUO2dCQUVSLDJCQUEyQjtnQkFDM0JVLFdBQVd2RCxHQUFHbUMsV0FBV0c7Z0JBRXpCLDhCQUE4QjtnQkFDOUJrQixjQUFjeEQsR0FBR21DLFdBQVdHO2dCQUU1QnRDLEVBQUVxQyxHQUFHO1lBQ1A7WUFFQSxNQUFNSyxzQkFBc0IsQ0FBQ1A7Z0JBQzNCLG1DQUFtQztnQkFDbkMsT0FBTztvQkFDTDVCLEdBQUc0QixTQUFTLENBQUMsRUFBRSxDQUFDNUIsQ0FBQztvQkFDakJGLEdBQUc4QixTQUFTLENBQUMsRUFBRSxDQUFDOUIsQ0FBQztvQkFDakI2QyxHQUFHZixTQUFTLENBQUMsRUFBRSxDQUFDZSxDQUFDO2dCQUNuQjtZQUNGO1lBRUEsTUFBTU4sd0JBQXdCLENBQUNUO2dCQUM3QixxREFBcUQ7Z0JBQ3JELE1BQU1zQixRQUFRdEIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLE1BQU11QixlQUFldkIsU0FBUyxDQUFDLEdBQUc7Z0JBQ2xDLE1BQU13QixjQUFjeEIsU0FBUyxDQUFDLEVBQUU7Z0JBRWhDLHdCQUF3QjtnQkFDeEIsTUFBTXlCLGFBQWE1RCxFQUFFNkQsWUFBWSxDQUMvQkgsYUFBYW5ELENBQUMsR0FBR2tELE1BQU1sRCxDQUFDLEVBQ3hCbUQsYUFBYXJELENBQUMsR0FBR29ELE1BQU1wRCxDQUFDLEVBQ3hCcUQsYUFBYVIsQ0FBQyxHQUFHTyxNQUFNUCxDQUFDO2dCQUcxQixPQUFPO29CQUNMM0MsR0FBR0ssS0FBS2tELEtBQUssQ0FBQ0YsV0FBV3ZELENBQUMsRUFBRXVELFdBQVdWLENBQUM7b0JBQ3hDN0MsR0FBR08sS0FBS2tELEtBQUssQ0FBQ0YsV0FBV3JELENBQUMsRUFBRXFELFdBQVdWLENBQUM7b0JBQ3hDQSxHQUFHdEMsS0FBS2tELEtBQUssQ0FBQ0YsV0FBV3ZELENBQUMsRUFBRXVELFdBQVdyRCxDQUFDO2dCQUMxQztZQUNGO1lBRUEsTUFBTXVDLHFCQUFxQixDQUFDWDtnQkFDMUIsMENBQTBDO2dCQUMxQyxNQUFNc0IsUUFBUXRCLFNBQVMsQ0FBQyxFQUFFO2dCQUMxQixNQUFNNEIsUUFBUTVCLFNBQVMsQ0FBQyxHQUFHO2dCQUMzQixNQUFNNkIsUUFBUTdCLFNBQVMsQ0FBQyxFQUFFO2dCQUUxQixNQUFNOEIsWUFBWXJELEtBQUtzRCxHQUFHLENBQUNILE1BQU14RCxDQUFDLEdBQUd5RCxNQUFNekQsQ0FBQztnQkFDNUMsT0FBT0ssS0FBS00sR0FBRyxDQUFDLEtBQUtOLEtBQUtPLEdBQUcsQ0FBQyxLQUFLOEMsWUFBWTtZQUNqRDtZQUVBLE1BQU1WLGFBQWEsQ0FBQ3ZELEdBQU9tQyxXQUFrQkc7Z0JBQzNDLG1EQUFtRDtnQkFDbkQsTUFBTTZCLGdCQUFnQjtvQkFBQztvQkFBRztvQkFBRztvQkFBRztvQkFBSTtpQkFBRyxFQUFFLHlCQUF5QjtnQkFFbEVuRSxFQUFFMkIsSUFBSTtnQkFDTjNCLEVBQUVvRSxPQUFPLENBQUNuRTtnQkFDVkQsRUFBRXFFLFFBQVE7Z0JBRVYsZ0NBQWdDO2dCQUNoQyxNQUFNWixRQUFRdEIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLE1BQU1tQyxhQUFhO29CQUNqQi9ELEdBQUcsQ0FBQ2tELE1BQU1sRCxDQUFDLEdBQUcsR0FBRSxJQUFLO29CQUNyQkYsR0FBRyxDQUFDb0QsTUFBTXBELENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQ3JCNkMsR0FBR08sTUFBTVAsQ0FBQztnQkFDWjtnQkFFQWxELEVBQUUyQixJQUFJO2dCQUNOM0IsRUFBRTRCLFNBQVMsQ0FBQzBDLFdBQVcvRCxDQUFDLEVBQUUrRCxXQUFXakUsQ0FBQyxFQUFFaUUsV0FBV3BCLENBQUM7Z0JBQ3BEbEQsRUFBRXVFLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxNQUFNLGFBQWE7Z0JBQ3pDdkUsRUFBRXdFLE1BQU0sQ0FBQztnQkFDVHhFLEVBQUVxQyxHQUFHO2dCQUVMLGdDQUFnQztnQkFDaEMsSUFBSyxJQUFJb0MsSUFBSSxHQUFHQSxJQUFJTixjQUFjM0IsTUFBTSxFQUFFaUMsSUFBSztvQkFDN0MsTUFBTUMsV0FBV3ZDLFNBQVMsQ0FBQ2dDLGFBQWEsQ0FBQ00sRUFBRSxDQUFDO29CQUM1QyxNQUFNbEUsSUFBSSxDQUFDbUUsU0FBU25FLENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQy9CLE1BQU1GLElBQUksQ0FBQ3FFLFNBQVNyRSxDQUFDLEdBQUcsR0FBRSxJQUFLO29CQUMvQixNQUFNNkMsSUFBSXdCLFNBQVN4QixDQUFDO29CQUVwQmxELEVBQUUyQixJQUFJO29CQUNOM0IsRUFBRTRCLFNBQVMsQ0FBQ3JCLEdBQUdGLEdBQUc2QztvQkFDbEJsRCxFQUFFdUUsSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLE1BQU0sYUFBYTtvQkFDekN2RSxFQUFFd0UsTUFBTSxDQUFDO29CQUNUeEUsRUFBRXFDLEdBQUc7Z0JBQ1A7Z0JBRUEsd0NBQXdDO2dCQUN4Q3JDLEVBQUUyRSxNQUFNO2dCQUNSM0UsRUFBRTRFLE1BQU0sQ0FBQyxLQUFLLEtBQUssS0FBSztnQkFDeEI1RSxFQUFFNkUsWUFBWSxDQUFDO2dCQUVmLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJTixjQUFjM0IsTUFBTSxHQUFHLEdBQUdpQyxJQUFLO29CQUNqRCxNQUFNM0UsVUFBVXFDLFNBQVMsQ0FBQ2dDLGFBQWEsQ0FBQ00sRUFBRSxDQUFDO29CQUMzQyxNQUFNSyxPQUFPM0MsU0FBUyxDQUFDZ0MsYUFBYSxDQUFDTSxJQUFJLEVBQUUsQ0FBQztvQkFFNUMsTUFBTU0sS0FBSyxDQUFDakYsUUFBUVMsQ0FBQyxHQUFHLEdBQUUsSUFBSztvQkFDL0IsTUFBTXlFLEtBQUssQ0FBQ2xGLFFBQVFPLENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQy9CLE1BQU00RSxLQUFLbkYsUUFBUW9ELENBQUM7b0JBRXBCLE1BQU1nQyxLQUFLLENBQUNKLEtBQUt2RSxDQUFDLEdBQUcsR0FBRSxJQUFLO29CQUM1QixNQUFNNEUsS0FBSyxDQUFDTCxLQUFLekUsQ0FBQyxHQUFHLEdBQUUsSUFBSztvQkFDNUIsTUFBTStFLEtBQUtOLEtBQUs1QixDQUFDO29CQUVqQmxELEVBQUVxRixJQUFJLENBQUNOLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO2dCQUM3QjtnQkFFQXBGLEVBQUVxQyxHQUFHO1lBQ1A7WUFFQSxNQUFNbUIsZ0JBQWdCLENBQUN4RCxHQUFPbUMsV0FBa0JHO2dCQUM5QywwQkFBMEI7Z0JBQzFCLE1BQU1nRCxnQkFBZ0I7b0JBQ3BCO3dCQUFDO3dCQUFHO3dCQUFHO3dCQUFHO3dCQUFHO3FCQUFFO29CQUNmO3dCQUFDO3dCQUFHO3dCQUFHO3dCQUFHO3FCQUFFO29CQUNaO3dCQUFDO3dCQUFJO3dCQUFJO3dCQUFJO3FCQUFFO29CQUNmO3dCQUFDO3dCQUFJO3dCQUFJO3dCQUFJO3FCQUFHO29CQUNoQjt3QkFBQzt3QkFBSTt3QkFBSTt3QkFBSTtxQkFBRyxDQUFJLFFBQVE7aUJBQzdCO2dCQUVEQSxjQUFjQyxPQUFPLENBQUMsQ0FBQ0MsUUFBUUM7b0JBQzdCQyxhQUFhMUYsR0FBR21DLFdBQVdxRCxRQUFRbEQsT0FBT21EO2dCQUM1QztZQUNGO1lBRUEsTUFBTUMsZUFBZSxDQUFDMUYsR0FBT21DLFdBQWtCbUQsZUFBeUJoRCxPQUFpQm1EO2dCQUN2RnpGLEVBQUUyQixJQUFJO2dCQUNOM0IsRUFBRW9FLE9BQU8sQ0FBQ25FO2dCQUVWLHlDQUF5QztnQkFDekMsSUFBSyxJQUFJd0UsSUFBSSxHQUFHQSxJQUFJYSxjQUFjOUMsTUFBTSxFQUFFaUMsSUFBSztvQkFDN0MsTUFBTUMsV0FBV3ZDLFNBQVMsQ0FBQ21ELGFBQWEsQ0FBQ2IsRUFBRSxDQUFDO29CQUM1QyxNQUFNbEUsSUFBSSxDQUFDbUUsU0FBU25FLENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQy9CLE1BQU1GLElBQUksQ0FBQ3FFLFNBQVNyRSxDQUFDLEdBQUcsR0FBRSxJQUFLO29CQUMvQixNQUFNNkMsSUFBSXdCLFNBQVN4QixDQUFDO29CQUVwQmxELEVBQUUyQixJQUFJO29CQUNOM0IsRUFBRTRCLFNBQVMsQ0FBQ3JCLEdBQUdGLEdBQUc2QztvQkFDbEIsTUFBTXlDLFlBQVksUUFBUyxLQUFJbEIsSUFBSSxHQUFFLEdBQUksc0JBQXNCO29CQUMvRHpFLEVBQUV1RSxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssTUFBTSxhQUFhO29CQUN6Q3ZFLEVBQUV3RSxNQUFNLENBQUNtQjtvQkFDVDNGLEVBQUVxQyxHQUFHO2dCQUNQO2dCQUVBLDBDQUEwQztnQkFDMUNyQyxFQUFFMkUsTUFBTTtnQkFDUjNFLEVBQUU0RSxNQUFNLENBQUMsS0FBSyxLQUFLLEtBQUs7Z0JBQ3hCNUUsRUFBRTZFLFlBQVksQ0FBQztnQkFFZixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSWEsY0FBYzlDLE1BQU0sR0FBRyxHQUFHaUMsSUFBSztvQkFDakQsTUFBTTNFLFVBQVVxQyxTQUFTLENBQUNtRCxhQUFhLENBQUNiLEVBQUUsQ0FBQztvQkFDM0MsTUFBTUssT0FBTzNDLFNBQVMsQ0FBQ21ELGFBQWEsQ0FBQ2IsSUFBSSxFQUFFLENBQUM7b0JBRTVDLE1BQU1NLEtBQUssQ0FBQ2pGLFFBQVFTLENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQy9CLE1BQU15RSxLQUFLLENBQUNsRixRQUFRTyxDQUFDLEdBQUcsR0FBRSxJQUFLO29CQUMvQixNQUFNNEUsS0FBS25GLFFBQVFvRCxDQUFDO29CQUVwQixNQUFNZ0MsS0FBSyxDQUFDSixLQUFLdkUsQ0FBQyxHQUFHLEdBQUUsSUFBSztvQkFDNUIsTUFBTTRFLEtBQUssQ0FBQ0wsS0FBS3pFLENBQUMsR0FBRyxHQUFFLElBQUs7b0JBQzVCLE1BQU0rRSxLQUFLTixLQUFLNUIsQ0FBQztvQkFFakJsRCxFQUFFcUYsSUFBSSxDQUFDTixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztnQkFDN0I7Z0JBRUFwRixFQUFFcUMsR0FBRztZQUNQO1FBQ0Y7UUFFQTdDLGNBQWNNLE9BQU8sR0FBRyxJQUFJWCwyQ0FBRUEsQ0FBQ1ksUUFBUVIsVUFBVU8sT0FBTztRQUV4RCxPQUFPO1lBQ0wsSUFBSU4sY0FBY00sT0FBTyxFQUFFO2dCQUN6Qk4sY0FBY00sT0FBTyxDQUFDOEYsTUFBTTtnQkFDNUJwRyxjQUFjTSxPQUFPLEdBQUc7WUFDMUI7UUFDRjtJQUNGLEdBQUc7UUFBQ1Q7UUFBVUM7S0FBVTtJQUV4Qix1REFBdUQ7SUFDdkQsTUFBTTRDLGtCQUFrQixTQUFDMkQsa0JBQXlCQyxtQkFBaUNDO1lBQW1CQyxtRkFBMEI7UUFDOUgsSUFBSSxDQUFDSCxvQkFBb0JBLGlCQUFpQnJELE1BQU0sS0FBSyxHQUFHO1lBQ3RELE9BQU9zRDtRQUNUO1FBRUEsSUFBSSxDQUFDQSxxQkFBcUJBLGtCQUFrQnRELE1BQU0sS0FBS3FELGlCQUFpQnJELE1BQU0sRUFBRTtZQUM5RSx3QkFBd0I7WUFDeEJ1RCxXQUFXdkQsTUFBTSxHQUFHcUQsaUJBQWlCckQsTUFBTTtZQUMzQyxJQUFLLElBQUlpQyxJQUFJLEdBQUdBLElBQUlvQixpQkFBaUJyRCxNQUFNLEVBQUVpQyxJQUFLO2dCQUNoRHNCLFVBQVUsQ0FBQ3RCLEVBQUUsR0FBRztvQkFBRWxFLEdBQUc7b0JBQUdGLEdBQUc7b0JBQUc2QyxHQUFHO2dCQUFFO1lBQ3JDO1lBQ0EsT0FBTzJDO1FBQ1Q7UUFFQSxNQUFNSSxvQkFBb0IsRUFBRTtRQUU1QixJQUFLLElBQUl4QixJQUFJLEdBQUdBLElBQUlvQixpQkFBaUJyRCxNQUFNLEVBQUVpQyxJQUFLO1lBQ2hELE1BQU0zRSxVQUFVK0YsZ0JBQWdCLENBQUNwQixFQUFFO1lBQ25DLE1BQU15QixXQUFXSixpQkFBaUIsQ0FBQ3JCLEVBQUU7WUFDckMsTUFBTTBCLFdBQVdKLFVBQVUsQ0FBQ3RCLEVBQUU7WUFFOUIsMENBQTBDO1lBQzFDLE1BQU0yQixTQUFTdEcsUUFBUVMsQ0FBQyxHQUFHMkYsU0FBUzNGLENBQUM7WUFDckMsTUFBTThGLFNBQVN2RyxRQUFRTyxDQUFDLEdBQUc2RixTQUFTN0YsQ0FBQztZQUNyQyxNQUFNaUcsU0FBU3hHLFFBQVFvRCxDQUFDLEdBQUdnRCxTQUFTaEQsQ0FBQztZQUVyQyxpQ0FBaUM7WUFDakNpRCxTQUFTNUYsQ0FBQyxHQUFHNEYsU0FBUzVGLENBQUMsR0FBRyxNQUFNNkYsU0FBUztZQUN6Q0QsU0FBUzlGLENBQUMsR0FBRzhGLFNBQVM5RixDQUFDLEdBQUcsTUFBTWdHLFNBQVM7WUFDekNGLFNBQVNqRCxDQUFDLEdBQUdpRCxTQUFTakQsQ0FBQyxHQUFHLE1BQU1vRCxTQUFTO1lBRXpDLGlDQUFpQztZQUNqQyxNQUFNQyxZQUFZTCxTQUFTM0YsQ0FBQyxHQUFHNEYsU0FBUzVGLENBQUMsR0FBR3lGO1lBQzVDLE1BQU1RLFlBQVlOLFNBQVM3RixDQUFDLEdBQUc4RixTQUFTOUYsQ0FBQyxHQUFHMkY7WUFDNUMsTUFBTVMsWUFBWVAsU0FBU2hELENBQUMsR0FBR2lELFNBQVNqRCxDQUFDLEdBQUc4QztZQUU1QyxrQ0FBa0M7WUFDbEMsTUFBTVUsV0FBVzlGLEtBQUtNLEdBQUcsQ0FBQyxHQUFHTixLQUFLTyxHQUFHLENBQUMsR0FBR29GO1lBQ3pDLE1BQU1JLFdBQVcvRixLQUFLTSxHQUFHLENBQUMsR0FBR04sS0FBS08sR0FBRyxDQUFDLEdBQUdxRjtZQUN6QyxNQUFNSSxXQUFXaEcsS0FBS00sR0FBRyxDQUFDLENBQUMsR0FBR04sS0FBS08sR0FBRyxDQUFDLEdBQUdzRjtZQUUxQ1Isa0JBQWtCdEUsSUFBSSxDQUFDO2dCQUNyQnBCLEdBQUdtRztnQkFDSHJHLEdBQUdzRztnQkFDSHpELEdBQUcwRDtZQUNMO1FBQ0Y7UUFFQSxPQUFPWDtJQUNUO0lBRUEscUJBQU8sOERBQUNZO1FBQUlDLEtBQUt2SDs7Ozs7O0FBQ25CO0dBOVV3Qkg7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSGFuZDNETW9kZWwudHN4PzM4ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBwNSBmcm9tICdwNSc7XG5pbXBvcnQgeyBIYW5kRGF0YSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5pbnRlcmZhY2UgSGFuZDNETW9kZWxQcm9wcyB7XG4gIGxlZnRIYW5kOiBIYW5kRGF0YSB8IG51bGw7XG4gIHJpZ2h0SGFuZDogSGFuZERhdGEgfCBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIYW5kM0RNb2RlbCh7IGxlZnRIYW5kLCByaWdodEhhbmQgfTogSGFuZDNETW9kZWxQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBwNUluc3RhbmNlUmVmID0gdXNlUmVmPHA1IHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBTbW9vdGhpbmcgYW5kIHN0YWJpbGl6YXRpb24gcmVmc1xuICBjb25zdCBwcmV2aW91c0xlZnRIYW5kID0gdXNlUmVmPGFueVtdIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzUmlnaHRIYW5kID0gdXNlUmVmPGFueVtdIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHZlbG9jaXR5TGVmdCA9IHVzZVJlZjxhbnlbXT4oW10pO1xuICBjb25zdCB2ZWxvY2l0eVJpZ2h0ID0gdXNlUmVmPGFueVtdPihbXSk7XG4gIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VSZWYoMCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBza2V0Y2ggPSAocDogcDUpID0+IHtcbiAgICAgIGxldCBoYW5kVGV4dHVyZTogcDUuSW1hZ2U7XG5cbiAgICAgIHAucHJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVhbGlzdGljIGhhbmQgdGV4dHVyZSBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICAgIGhhbmRUZXh0dXJlID0gcC5jcmVhdGVJbWFnZSgxMjgsIDEyOCk7XG4gICAgICAgIGhhbmRUZXh0dXJlLmxvYWRQaXhlbHMoKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGFuZFRleHR1cmUuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGhhbmRUZXh0dXJlLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKHkgKiBoYW5kVGV4dHVyZS53aWR0aCArIHgpICogNDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHNraW4tbGlrZSBjb2xvciB3aXRoIHZhcmlhdGlvblxuICAgICAgICAgICAgY29uc3QgYmFzZVIgPSAyNTU7XG4gICAgICAgICAgICBjb25zdCBiYXNlRyA9IDIwMCArIE1hdGguc2luKHggKiAwLjEpICogMjA7XG4gICAgICAgICAgICBjb25zdCBiYXNlQiA9IDE1MCArIE1hdGguY29zKHkgKiAwLjEpICogMTU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBzb21lIHRleHR1cmUgdmFyaWF0aW9uXG4gICAgICAgICAgICBjb25zdCBub2lzZSA9IE1hdGguc2luKHggKiAwLjA1KSAqIE1hdGguY29zKHkgKiAwLjA1KSAqIDEwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoYW5kVGV4dHVyZS5waXhlbHNbaW5kZXhdID0gTWF0aC5tYXgoMjAwLCBNYXRoLm1pbigyNTUsIGJhc2VSICsgbm9pc2UpKTsgICAgIC8vIFJcbiAgICAgICAgICAgIGhhbmRUZXh0dXJlLnBpeGVsc1tpbmRleCArIDFdID0gTWF0aC5tYXgoMTgwLCBNYXRoLm1pbigyMjAsIGJhc2VHICsgbm9pc2UpKTsgLy8gR1xuICAgICAgICAgICAgaGFuZFRleHR1cmUucGl4ZWxzW2luZGV4ICsgMl0gPSBNYXRoLm1heCgxNDAsIE1hdGgubWluKDE3MCwgYmFzZUIgKyBub2lzZSkpOyAvLyBCXG4gICAgICAgICAgICBoYW5kVGV4dHVyZS5waXhlbHNbaW5kZXggKyAzXSA9IDI1NTsgLy8gQVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kVGV4dHVyZS51cGRhdGVQaXhlbHMoKTtcbiAgICAgIH07XG5cbiAgICAgIHAuc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIHAuY3JlYXRlQ2FudmFzKDgwMCwgNjQwLCBwLldFQkdMKTtcbiAgICAgICAgcC5mcmFtZVJhdGUoNjApO1xuICAgICAgfTtcblxuICAgICAgcC5kcmF3ID0gKCkgPT4ge1xuICAgICAgICBwLmNsZWFyKCk7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRyYW5zbGF0ZSgwLCAwLCAtMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB1cCBsaWdodGluZ1xuICAgICAgICBwLmFtYmllbnRMaWdodCg2MCwgNjAsIDYwKTtcbiAgICAgICAgcC5kaXJlY3Rpb25hbExpZ2h0KDI1NSwgMjU1LCAyNTUsIDAsIDAsIC0xKTtcbiAgICAgICAgcC5wb2ludExpZ2h0KDI1NSwgMjU1LCAyNTUsIDAsIDAsIDApO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgc21vb3RoaW5nIHRvIGxhbmRtYXJrc1xuICAgICAgICBsZXQgc21vb3RoZWRMZWZ0TGFuZG1hcmtzID0gbnVsbDtcbiAgICAgICAgbGV0IHNtb290aGVkUmlnaHRMYW5kbWFya3MgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxlZnRIYW5kKSB7XG4gICAgICAgICAgc21vb3RoZWRMZWZ0TGFuZG1hcmtzID0gc21vb3RoTGFuZG1hcmtzKGxlZnRIYW5kLmxhbmRtYXJrcywgcHJldmlvdXNMZWZ0SGFuZC5jdXJyZW50LCB2ZWxvY2l0eUxlZnQuY3VycmVudCwgMC4yNSk7XG4gICAgICAgICAgcHJldmlvdXNMZWZ0SGFuZC5jdXJyZW50ID0gc21vb3RoZWRMZWZ0TGFuZG1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocmlnaHRIYW5kKSB7XG4gICAgICAgICAgc21vb3RoZWRSaWdodExhbmRtYXJrcyA9IHNtb290aExhbmRtYXJrcyhyaWdodEhhbmQubGFuZG1hcmtzLCBwcmV2aW91c1JpZ2h0SGFuZC5jdXJyZW50LCB2ZWxvY2l0eVJpZ2h0LmN1cnJlbnQsIDAuMjUpO1xuICAgICAgICAgIHByZXZpb3VzUmlnaHRIYW5kLmN1cnJlbnQgPSBzbW9vdGhlZFJpZ2h0TGFuZG1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgbGVmdCBoYW5kIHdpdGggc21vb3RoZWQgbGFuZG1hcmtzXG4gICAgICAgIGlmIChzbW9vdGhlZExlZnRMYW5kbWFya3MpIHtcbiAgICAgICAgICByZW5kZXJIYW5kM0QocCwgc21vb3RoZWRMZWZ0TGFuZG1hcmtzLCBbMCwgMjU1LCAwXSwgJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVuZGVyIHJpZ2h0IGhhbmQgd2l0aCBzbW9vdGhlZCBsYW5kbWFya3NcbiAgICAgICAgaWYgKHNtb290aGVkUmlnaHRMYW5kbWFya3MpIHtcbiAgICAgICAgICByZW5kZXJIYW5kM0QocCwgc21vb3RoZWRSaWdodExhbmRtYXJrcywgWzAsIDAsIDI1NV0sICdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwLnBvcCgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVuZGVySGFuZDNEID0gKHA6IHA1LCBsYW5kbWFya3M6IGFueVtdLCBjb2xvcjogbnVtYmVyW10sIGhhbmRUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFsYW5kbWFya3MgfHwgbGFuZG1hcmtzLmxlbmd0aCA8IDIxKSByZXR1cm47XG5cbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgaGFuZCBjZW50ZXIgYW5kIG9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IGhhbmRDZW50ZXIgPSBjYWxjdWxhdGVIYW5kQ2VudGVyKGxhbmRtYXJrcyk7XG4gICAgICAgIGNvbnN0IGhhbmRSb3RhdGlvbiA9IGNhbGN1bGF0ZUhhbmRSb3RhdGlvbihsYW5kbWFya3MpO1xuICAgICAgICBjb25zdCBoYW5kU2NhbGUgPSBjYWxjdWxhdGVIYW5kU2NhbGUobGFuZG1hcmtzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyYW5zZm9ybSB0byBoYW5kIHBvc2l0aW9uIHdpdGggc3RhYmxlIGNvb3JkaW5hdGUgbWFwcGluZ1xuICAgICAgICBjb25zdCBzY3JlZW5YID0gLWhhbmRDZW50ZXIueCAqIHAud2lkdGggKyBwLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3Qgc2NyZWVuWSA9IGhhbmRDZW50ZXIueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCBzY3JlZW5aID0gaGFuZENlbnRlci56ICogNTA7IC8vIFJlZHVjZWQgZGVwdGggZm9yIHN0YWJpbGl0eVxuICAgICAgICBcbiAgICAgICAgcC50cmFuc2xhdGUoc2NyZWVuWCwgc2NyZWVuWSwgc2NyZWVuWik7XG4gICAgICAgIHAucm90YXRlWChoYW5kUm90YXRpb24ueCk7XG4gICAgICAgIHAucm90YXRlWShoYW5kUm90YXRpb24ueSk7XG4gICAgICAgIHAucm90YXRlWihoYW5kUm90YXRpb24ueik7XG4gICAgICAgIHAuc2NhbGUoaGFuZFNjYWxlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbmRlciBwYWxtIHdpdGggdGV4dHVyZVxuICAgICAgICByZW5kZXJQYWxtKHAsIGxhbmRtYXJrcywgY29sb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVuZGVyIGZpbmdlcnMgd2l0aCB0ZXh0dXJlXG4gICAgICAgIHJlbmRlckZpbmdlcnMocCwgbGFuZG1hcmtzLCBjb2xvcik7XG4gICAgICAgIFxuICAgICAgICBwLnBvcCgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FsY3VsYXRlSGFuZENlbnRlciA9IChsYW5kbWFya3M6IGFueVtdKSA9PiB7XG4gICAgICAgIC8vIFVzZSB3cmlzdCAobGFuZG1hcmsgMCkgYXMgY2VudGVyXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogbGFuZG1hcmtzWzBdLngsXG4gICAgICAgICAgeTogbGFuZG1hcmtzWzBdLnksXG4gICAgICAgICAgejogbGFuZG1hcmtzWzBdLnpcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUhhbmRSb3RhdGlvbiA9IChsYW5kbWFya3M6IGFueVtdKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBoYW5kIG9yaWVudGF0aW9uIGJhc2VkIG9uIHBhbG0gbGFuZG1hcmtzXG4gICAgICAgIGNvbnN0IHdyaXN0ID0gbGFuZG1hcmtzWzBdO1xuICAgICAgICBjb25zdCBtaWRkbGVGaW5nZXIgPSBsYW5kbWFya3NbMTJdO1xuICAgICAgICBjb25zdCBpbmRleEZpbmdlciA9IGxhbmRtYXJrc1s4XTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBwYWxtIG5vcm1hbFxuICAgICAgICBjb25zdCBwYWxtTm9ybWFsID0gcC5jcmVhdGVWZWN0b3IoXG4gICAgICAgICAgbWlkZGxlRmluZ2VyLnggLSB3cmlzdC54LFxuICAgICAgICAgIG1pZGRsZUZpbmdlci55IC0gd3Jpc3QueSxcbiAgICAgICAgICBtaWRkbGVGaW5nZXIueiAtIHdyaXN0LnpcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5hdGFuMihwYWxtTm9ybWFsLnksIHBhbG1Ob3JtYWwueiksXG4gICAgICAgICAgeTogTWF0aC5hdGFuMihwYWxtTm9ybWFsLngsIHBhbG1Ob3JtYWwueiksXG4gICAgICAgICAgejogTWF0aC5hdGFuMihwYWxtTm9ybWFsLnksIHBhbG1Ob3JtYWwueClcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUhhbmRTY2FsZSA9IChsYW5kbWFya3M6IGFueVtdKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBoYW5kIHNpemUgYmFzZWQgb24gcGFsbSB3aWR0aFxuICAgICAgICBjb25zdCB3cmlzdCA9IGxhbmRtYXJrc1swXTtcbiAgICAgICAgY29uc3QgcGlua3kgPSBsYW5kbWFya3NbMTddO1xuICAgICAgICBjb25zdCB0aHVtYiA9IGxhbmRtYXJrc1s0XTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhbG1XaWR0aCA9IE1hdGguYWJzKHBpbmt5LnggLSB0aHVtYi54KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAuNSwgTWF0aC5taW4oMi4wLCBwYWxtV2lkdGggKiAxMCkpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVuZGVyUGFsbSA9IChwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgY29sb3I6IG51bWJlcltdKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBwYWxtIHVzaW5nIHRleHR1cmVkIHNwaGVyZXMgYXQga2V5IHBvaW50c1xuICAgICAgICBjb25zdCBwYWxtTGFuZG1hcmtzID0gWzAsIDUsIDksIDEzLCAxN107IC8vIFdyaXN0IGFuZCBmaW5nZXIgYmFzZXNcbiAgICAgICAgXG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRleHR1cmUoaGFuZFRleHR1cmUpO1xuICAgICAgICBwLm5vU3Ryb2tlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHBhbG0gY2VudGVyIHdpdGggdGV4dHVyZVxuICAgICAgICBjb25zdCB3cmlzdCA9IGxhbmRtYXJrc1swXTtcbiAgICAgICAgY29uc3QgcGFsbUNlbnRlciA9IHtcbiAgICAgICAgICB4OiAod3Jpc3QueCAtIDAuNSkgKiAyLFxuICAgICAgICAgIHk6ICh3cmlzdC55IC0gMC41KSAqIDIsXG4gICAgICAgICAgejogd3Jpc3QuelxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAudHJhbnNsYXRlKHBhbG1DZW50ZXIueCwgcGFsbUNlbnRlci55LCBwYWxtQ2VudGVyLnopO1xuICAgICAgICBwLmZpbGwoMjU1LCAyMDAsIDE1MCwgMjAwKTsgLy8gU2tpbiBjb2xvclxuICAgICAgICBwLnNwaGVyZSgwLjA4KTtcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcGFsbSBqb2ludHMgd2l0aCB0ZXh0dXJlXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFsbUxhbmRtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gbGFuZG1hcmtzW3BhbG1MYW5kbWFya3NbaV1dO1xuICAgICAgICAgIGNvbnN0IHggPSAobGFuZG1hcmsueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkgPSAobGFuZG1hcmsueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHogPSBsYW5kbWFyay56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgIHAudHJhbnNsYXRlKHgsIHksIHopO1xuICAgICAgICAgIHAuZmlsbCgyNTUsIDIwMCwgMTUwLCAxODApOyAvLyBTa2luIGNvbG9yXG4gICAgICAgICAgcC5zcGhlcmUoMC4wNSk7XG4gICAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBwYWxtIGNvbm5lY3Rpb25zIHdpdGggc2tpbiBjb2xvclxuICAgICAgICBwLm5vRmlsbCgpO1xuICAgICAgICBwLnN0cm9rZSgyNTUsIDIwMCwgMTUwLCAxMjApO1xuICAgICAgICBwLnN0cm9rZVdlaWdodCg0KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFsbUxhbmRtYXJrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbGFuZG1hcmtzW3BhbG1MYW5kbWFya3NbaV1dO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBsYW5kbWFya3NbcGFsbUxhbmRtYXJrc1tpICsgMV1dO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgxID0gKGN1cnJlbnQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkxID0gKGN1cnJlbnQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoxID0gY3VycmVudC56O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgyID0gKG5leHQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkyID0gKG5leHQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoyID0gbmV4dC56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAubGluZSh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlckZpbmdlcnMgPSAocDogcDUsIGxhbmRtYXJrczogYW55W10sIGNvbG9yOiBudW1iZXJbXSkgPT4ge1xuICAgICAgICAvLyBGaW5nZXIgbGFuZG1hcmsgaW5kaWNlc1xuICAgICAgICBjb25zdCBmaW5nZXJJbmRpY2VzID0gW1xuICAgICAgICAgIFs0LCAzLCAyLCAxLCAwXSwgICAgLy8gVGh1bWJcbiAgICAgICAgICBbOCwgNywgNiwgNV0sICAgICAgIC8vIEluZGV4XG4gICAgICAgICAgWzEyLCAxMSwgMTAsIDldLCAgICAvLyBNaWRkbGVcbiAgICAgICAgICBbMTYsIDE1LCAxNCwgMTNdLCAgIC8vIFJpbmdcbiAgICAgICAgICBbMjAsIDE5LCAxOCwgMTddICAgIC8vIFBpbmt5XG4gICAgICAgIF07XG5cbiAgICAgICAgZmluZ2VySW5kaWNlcy5mb3JFYWNoKChmaW5nZXIsIGZpbmdlckluZGV4KSA9PiB7XG4gICAgICAgICAgcmVuZGVyRmluZ2VyKHAsIGxhbmRtYXJrcywgZmluZ2VyLCBjb2xvciwgZmluZ2VySW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlbmRlckZpbmdlciA9IChwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgZmluZ2VySW5kaWNlczogbnVtYmVyW10sIGNvbG9yOiBudW1iZXJbXSwgZmluZ2VySW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC50ZXh0dXJlKGhhbmRUZXh0dXJlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgZmluZ2VyIGpvaW50cyBhcyB0ZXh0dXJlZCBzcGhlcmVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluZ2VySW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxhbmRtYXJrID0gbGFuZG1hcmtzW2ZpbmdlckluZGljZXNbaV1dO1xuICAgICAgICAgIGNvbnN0IHggPSAobGFuZG1hcmsueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkgPSAobGFuZG1hcmsueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHogPSBsYW5kbWFyay56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAucHVzaCgpO1xuICAgICAgICAgIHAudHJhbnNsYXRlKHgsIHksIHopO1xuICAgICAgICAgIGNvbnN0IGpvaW50U2l6ZSA9IDAuMDI1ICogKDEgLSBpICogMC4xKTsgLy8gU21hbGxlciB0b3dhcmRzIHRpcFxuICAgICAgICAgIHAuZmlsbCgyNTUsIDIwMCwgMTUwLCAyMDApOyAvLyBTa2luIGNvbG9yXG4gICAgICAgICAgcC5zcGhlcmUoam9pbnRTaXplKTtcbiAgICAgICAgICBwLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IGZpbmdlciBjb25uZWN0aW9ucyB3aXRoIHNraW4gY29sb3JcbiAgICAgICAgcC5ub0ZpbGwoKTtcbiAgICAgICAgcC5zdHJva2UoMjU1LCAyMDAsIDE1MCwgMTUwKTtcbiAgICAgICAgcC5zdHJva2VXZWlnaHQoMyk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmdlckluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IGxhbmRtYXJrc1tmaW5nZXJJbmRpY2VzW2ldXTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbGFuZG1hcmtzW2ZpbmdlckluZGljZXNbaSArIDFdXTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB4MSA9IChjdXJyZW50LnggLSAwLjUpICogMjtcbiAgICAgICAgICBjb25zdCB5MSA9IChjdXJyZW50LnkgLSAwLjUpICogMjtcbiAgICAgICAgICBjb25zdCB6MSA9IGN1cnJlbnQuejtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB4MiA9IChuZXh0LnggLSAwLjUpICogMjtcbiAgICAgICAgICBjb25zdCB5MiA9IChuZXh0LnkgLSAwLjUpICogMjtcbiAgICAgICAgICBjb25zdCB6MiA9IG5leHQuejtcbiAgICAgICAgICBcbiAgICAgICAgICBwLmxpbmUoeDEsIHkxLCB6MSwgeDIsIHkyLCB6Mik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQgPSBuZXcgcDUoc2tldGNoLCBjYW52YXNSZWYuY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHA1SW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICBwNUluc3RhbmNlUmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2xlZnRIYW5kLCByaWdodEhhbmRdKTtcblxuICAvLyBTbW9vdGhpbmcgZnVuY3Rpb24gd2l0aCB2ZWxvY2l0eS1iYXNlZCBpbnRlcnBvbGF0aW9uXG4gIGNvbnN0IHNtb290aExhbmRtYXJrcyA9IChjdXJyZW50TGFuZG1hcmtzOiBhbnlbXSwgcHJldmlvdXNMYW5kbWFya3M6IGFueVtdIHwgbnVsbCwgdmVsb2NpdGllczogYW55W10sIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyID0gMC4zKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50TGFuZG1hcmtzIHx8IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJldmlvdXNMYW5kbWFya3M7XG4gICAgfVxuICAgIFxuICAgIGlmICghcHJldmlvdXNMYW5kbWFya3MgfHwgcHJldmlvdXNMYW5kbWFya3MubGVuZ3RoICE9PSBjdXJyZW50TGFuZG1hcmtzLmxlbmd0aCkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSB2ZWxvY2l0aWVzXG4gICAgICB2ZWxvY2l0aWVzLmxlbmd0aCA9IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGFuZG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZlbG9jaXRpZXNbaV0gPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50TGFuZG1hcmtzO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBzbW9vdGhlZExhbmRtYXJrcyA9IFtdO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExhbmRtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudCA9IGN1cnJlbnRMYW5kbWFya3NbaV07XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHByZXZpb3VzTGFuZG1hcmtzW2ldO1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB2ZWxvY2l0aWVzW2ldO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdmVsb2NpdHkgKGNoYW5nZSBpbiBwb3NpdGlvbilcbiAgICAgIGNvbnN0IGRlbHRhWCA9IGN1cnJlbnQueCAtIHByZXZpb3VzLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSBjdXJyZW50LnkgLSBwcmV2aW91cy55O1xuICAgICAgY29uc3QgZGVsdGFaID0gY3VycmVudC56IC0gcHJldmlvdXMuejtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHZlbG9jaXR5IHdpdGggc21vb3RoaW5nXG4gICAgICB2ZWxvY2l0eS54ID0gdmVsb2NpdHkueCAqIDAuOCArIGRlbHRhWCAqIDAuMjtcbiAgICAgIHZlbG9jaXR5LnkgPSB2ZWxvY2l0eS55ICogMC44ICsgZGVsdGFZICogMC4yO1xuICAgICAgdmVsb2NpdHkueiA9IHZlbG9jaXR5LnogKiAwLjggKyBkZWx0YVogKiAwLjI7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHZlbG9jaXR5LWJhc2VkIHNtb290aGluZ1xuICAgICAgY29uc3Qgc21vb3RoZWRYID0gcHJldmlvdXMueCArIHZlbG9jaXR5LnggKiBzbW9vdGhpbmdGYWN0b3I7XG4gICAgICBjb25zdCBzbW9vdGhlZFkgPSBwcmV2aW91cy55ICsgdmVsb2NpdHkueSAqIHNtb290aGluZ0ZhY3RvcjtcbiAgICAgIGNvbnN0IHNtb290aGVkWiA9IHByZXZpb3VzLnogKyB2ZWxvY2l0eS56ICogc21vb3RoaW5nRmFjdG9yO1xuICAgICAgXG4gICAgICAvLyBDbGFtcCB0byBwcmV2ZW50IGV4dHJlbWUgdmFsdWVzXG4gICAgICBjb25zdCBjbGFtcGVkWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNtb290aGVkWCkpO1xuICAgICAgY29uc3QgY2xhbXBlZFkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzbW9vdGhlZFkpKTtcbiAgICAgIGNvbnN0IGNsYW1wZWRaID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHNtb290aGVkWikpO1xuICAgICAgXG4gICAgICBzbW9vdGhlZExhbmRtYXJrcy5wdXNoKHtcbiAgICAgICAgeDogY2xhbXBlZFgsXG4gICAgICAgIHk6IGNsYW1wZWRZLFxuICAgICAgICB6OiBjbGFtcGVkWlxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbW9vdGhlZExhbmRtYXJrcztcbiAgfTtcblxuICByZXR1cm4gPGRpdiByZWY9e2NhbnZhc1JlZn0gLz47XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJwNSIsIkhhbmQzRE1vZGVsIiwibGVmdEhhbmQiLCJyaWdodEhhbmQiLCJjYW52YXNSZWYiLCJwNUluc3RhbmNlUmVmIiwicHJldmlvdXNMZWZ0SGFuZCIsInByZXZpb3VzUmlnaHRIYW5kIiwidmVsb2NpdHlMZWZ0IiwidmVsb2NpdHlSaWdodCIsImZyYW1lQ291bnQiLCJjdXJyZW50Iiwic2tldGNoIiwicCIsImhhbmRUZXh0dXJlIiwicHJlbG9hZCIsImNyZWF0ZUltYWdlIiwibG9hZFBpeGVscyIsInkiLCJoZWlnaHQiLCJ4Iiwid2lkdGgiLCJpbmRleCIsImJhc2VSIiwiYmFzZUciLCJNYXRoIiwic2luIiwiYmFzZUIiLCJjb3MiLCJub2lzZSIsInBpeGVscyIsIm1heCIsIm1pbiIsInVwZGF0ZVBpeGVscyIsInNldHVwIiwiY3JlYXRlQ2FudmFzIiwiV0VCR0wiLCJmcmFtZVJhdGUiLCJkcmF3IiwiY2xlYXIiLCJwdXNoIiwidHJhbnNsYXRlIiwiYW1iaWVudExpZ2h0IiwiZGlyZWN0aW9uYWxMaWdodCIsInBvaW50TGlnaHQiLCJzbW9vdGhlZExlZnRMYW5kbWFya3MiLCJzbW9vdGhlZFJpZ2h0TGFuZG1hcmtzIiwic21vb3RoTGFuZG1hcmtzIiwibGFuZG1hcmtzIiwicmVuZGVySGFuZDNEIiwicG9wIiwiY29sb3IiLCJoYW5kVHlwZSIsImxlbmd0aCIsImhhbmRDZW50ZXIiLCJjYWxjdWxhdGVIYW5kQ2VudGVyIiwiaGFuZFJvdGF0aW9uIiwiY2FsY3VsYXRlSGFuZFJvdGF0aW9uIiwiaGFuZFNjYWxlIiwiY2FsY3VsYXRlSGFuZFNjYWxlIiwic2NyZWVuWCIsInNjcmVlblkiLCJzY3JlZW5aIiwieiIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsInNjYWxlIiwicmVuZGVyUGFsbSIsInJlbmRlckZpbmdlcnMiLCJ3cmlzdCIsIm1pZGRsZUZpbmdlciIsImluZGV4RmluZ2VyIiwicGFsbU5vcm1hbCIsImNyZWF0ZVZlY3RvciIsImF0YW4yIiwicGlua3kiLCJ0aHVtYiIsInBhbG1XaWR0aCIsImFicyIsInBhbG1MYW5kbWFya3MiLCJ0ZXh0dXJlIiwibm9TdHJva2UiLCJwYWxtQ2VudGVyIiwiZmlsbCIsInNwaGVyZSIsImkiLCJsYW5kbWFyayIsIm5vRmlsbCIsInN0cm9rZSIsInN0cm9rZVdlaWdodCIsIm5leHQiLCJ4MSIsInkxIiwiejEiLCJ4MiIsInkyIiwiejIiLCJsaW5lIiwiZmluZ2VySW5kaWNlcyIsImZvckVhY2giLCJmaW5nZXIiLCJmaW5nZXJJbmRleCIsInJlbmRlckZpbmdlciIsImpvaW50U2l6ZSIsInJlbW92ZSIsImN1cnJlbnRMYW5kbWFya3MiLCJwcmV2aW91c0xhbmRtYXJrcyIsInZlbG9jaXRpZXMiLCJzbW9vdGhpbmdGYWN0b3IiLCJzbW9vdGhlZExhbmRtYXJrcyIsInByZXZpb3VzIiwidmVsb2NpdHkiLCJkZWx0YVgiLCJkZWx0YVkiLCJkZWx0YVoiLCJzbW9vdGhlZFgiLCJzbW9vdGhlZFkiLCJzbW9vdGhlZFoiLCJjbGFtcGVkWCIsImNsYW1wZWRZIiwiY2xhbXBlZFoiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Hand3DModel.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Sketch_tsx",{

/***/ "(app-pages-browser)/./src/components/Sketch.tsx":
/*!***********************************!*\
  !*** ./src/components/Sketch.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sketch; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Sketch(param) {\n    let { multiHandData, videoRef } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const smoothedLandmarksRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        leftHand: null,\n        rightHand: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let objectVector;\n            let objectSize = 1;\n            let lastObjectSize = 1;\n            let objectSizeSmooth = 0;\n            let grabbing = false;\n            let locked = false;\n            p.setup = ()=>{\n                objectVector = p.createVector(100, 0, 0);\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(60); // Set to 60 FPS for smooth rendering\n                // Use system font instead of loading custom font\n                try {\n                    p.textFont('system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif');\n                } catch (error) {\n                    console.warn(\"Font loading failed, using default:\", error);\n                    // Fallback to default font\n                    p.textFont(\"Arial\");\n                }\n                p.textSize(12);\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                p.pop();\n                // Enhanced gesture display\n                p.strokeWeight(5);\n                // Color based on gesture type (using primary hand)\n                let gestureColor;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                if (primaryHand) {\n                    switch(primaryHand.gesture){\n                        case \"pinch\":\n                            gestureColor = p.color(255, 0, 0); // Red\n                            break;\n                        case \"fist\":\n                            gestureColor = p.color(255, 165, 0); // Orange\n                            break;\n                        case \"openHand\":\n                            gestureColor = p.color(0, 255, 0); // Green\n                            break;\n                        case \"pointing\":\n                            gestureColor = p.color(0, 255, 255); // Cyan\n                            break;\n                        case \"victory\":\n                            gestureColor = p.color(255, 0, 255); // Magenta\n                            break;\n                        default:\n                            gestureColor = p.color(128, 128, 128); // Gray\n                    }\n                } else {\n                    gestureColor = p.color(128, 128, 128); // Gray\n                }\n                p.stroke(gestureColor);\n                // Draw gesture indicator line\n                const lineLength = primaryHand ? primaryHand.confidence * 300 : 0;\n                p.line(0, 0, lineLength, 0);\n                // Draw object which is being dragged\n                p.push();\n                p.fill(0, 0, 255, 100);\n                p.stroke(0, 0, 255);\n                p.translate(objectVector.x, objectVector.y, objectVector.z);\n                p.ellipse(0, 0, 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth), 100 * p.map(objectVector.z, 0.1, -0.1, 0.1, objectSizeSmooth));\n                p.pop();\n                // Draw landmarks\n                displayResults(p);\n                // Enhanced gesture-based interaction\n                if ((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) === \"pinch\") {\n                    grabbing = true;\n                } else {\n                    grabbing = false;\n                }\n                // Handle grabbing interaction with the object\n                if (grabbing && primaryHand) {\n                    // Use thumb tip (4) and index tip (8) for pinch position\n                    const thumbTip = primaryHand.landmarks[4];\n                    const indexTip = primaryHand.landmarks[8];\n                    // Calculate pinch center position\n                    const pinchX = (thumbTip.x + indexTip.x) / 2;\n                    const pinchY = (thumbTip.y + indexTip.y) / 2;\n                    const pinchZ = (thumbTip.z + indexTip.z) / 2;\n                    // Map to world coordinates\n                    let pinchVector = p.createVector(pinchX * p.width - p.width / 2, pinchY * p.height - p.height / 2, pinchZ);\n                    if (p.dist(pinchVector.x, pinchVector.y, objectVector.x, objectVector.y) < 50 && locked == false) {\n                        locked = true;\n                        objectSize = 2;\n                    }\n                    if (locked) {\n                        objectVector.x = pinchVector.x;\n                        objectVector.y = pinchVector.y;\n                        objectVector.z = pinchVector.z;\n                    }\n                } else {\n                    locked = false;\n                    objectSize = 1;\n                }\n                // Smooth object size\n                objectSizeSmooth = objectSize * 0.5 + lastObjectSize * 0.5;\n                lastObjectSize = objectSizeSmooth;\n                // Draw privacy indicator only\n                drawPrivacyIndicator(p);\n            };\n            // Enhanced smoothing with persistence\n            const smoothLandmarks = function(currentLandmarks, previousLandmarks) {\n                let smoothingFactor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n                if (!currentLandmarks || currentLandmarks.length === 0) {\n                    return previousLandmarks; // Keep previous landmarks if no new ones\n                }\n                if (!previousLandmarks || previousLandmarks.length !== currentLandmarks.length) {\n                    return currentLandmarks;\n                }\n                return currentLandmarks.map((landmark, index)=>{\n                    const prev = previousLandmarks[index];\n                    if (!prev) return landmark;\n                    // More aggressive smoothing for stability\n                    return {\n                        x: prev.x + (landmark.x - prev.x) * smoothingFactor,\n                        y: prev.y + (landmark.y - prev.y) * smoothingFactor,\n                        z: prev.z + (landmark.z - prev.z) * smoothingFactor\n                    };\n                });\n            };\n            function displayResults(p) {\n                // Smooth left hand landmarks\n                if (multiHandData.leftHand) {\n                    const smoothedLeft = smoothLandmarks(multiHandData.leftHand.landmarks, smoothedLandmarksRef.current.leftHand);\n                    smoothedLandmarksRef.current.leftHand = smoothedLeft;\n                    // Draw left hand landmarks (green)\n                    p.stroke(0, 255, 0); // Green for left hand\n                    p.strokeWeight(4);\n                    p.fill(0, 255, 0, 100);\n                    // Draw connections between landmarks for better visualization\n                    for(let i = 0; i < smoothedLeft.length; i++){\n                        const landmark = smoothedLeft[i];\n                        const x = landmark.x * p.width - p.width / 2;\n                        const y = landmark.y * p.height - p.height / 2;\n                        const z = landmark.z;\n                        // Draw landmark point\n                        p.push();\n                        p.translate(x, y, z);\n                        p.sphere(3);\n                        p.pop();\n                    }\n                    // Draw hand connections (finger bones)\n                    drawHandConnections(p, smoothedLeft, 0, 255, 0);\n                } else {\n                    smoothedLandmarksRef.current.leftHand = null;\n                }\n                // Smooth right hand landmarks\n                if (multiHandData.rightHand) {\n                    const smoothedRight = smoothLandmarks(multiHandData.rightHand.landmarks, smoothedLandmarksRef.current.rightHand);\n                    smoothedLandmarksRef.current.rightHand = smoothedRight;\n                    // Draw right hand landmarks (blue)\n                    p.stroke(0, 0, 255); // Blue for right hand\n                    p.strokeWeight(4);\n                    p.fill(0, 0, 255, 100);\n                    // Draw connections between landmarks for better visualization\n                    for(let i = 0; i < smoothedRight.length; i++){\n                        const landmark = smoothedRight[i];\n                        const x = landmark.x * p.width - p.width / 2;\n                        const y = landmark.y * p.height - p.height / 2;\n                        const z = landmark.z;\n                        // Draw landmark point\n                        p.push();\n                        p.translate(x, y, z);\n                        p.sphere(3);\n                        p.pop();\n                    }\n                    // Draw hand connections (finger bones)\n                    drawHandConnections(p, smoothedRight, 0, 0, 255);\n                } else {\n                    smoothedLandmarksRef.current.rightHand = null;\n                }\n            }\n            function drawHandConnections(p, landmarks, r, g, b) {\n                // MediaPipe hand connections (finger bones)\n                const connections = [\n                    // Thumb\n                    [\n                        0,\n                        1\n                    ],\n                    [\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        3\n                    ],\n                    [\n                        3,\n                        4\n                    ],\n                    // Index finger\n                    [\n                        0,\n                        5\n                    ],\n                    [\n                        5,\n                        6\n                    ],\n                    [\n                        6,\n                        7\n                    ],\n                    [\n                        7,\n                        8\n                    ],\n                    // Middle finger\n                    [\n                        0,\n                        9\n                    ],\n                    [\n                        9,\n                        10\n                    ],\n                    [\n                        10,\n                        11\n                    ],\n                    [\n                        11,\n                        12\n                    ],\n                    // Ring finger\n                    [\n                        0,\n                        13\n                    ],\n                    [\n                        13,\n                        14\n                    ],\n                    [\n                        14,\n                        15\n                    ],\n                    [\n                        15,\n                        16\n                    ],\n                    // Pinky\n                    [\n                        0,\n                        17\n                    ],\n                    [\n                        17,\n                        18\n                    ],\n                    [\n                        18,\n                        19\n                    ],\n                    [\n                        19,\n                        20\n                    ],\n                    // Palm connections\n                    [\n                        5,\n                        9\n                    ],\n                    [\n                        9,\n                        13\n                    ],\n                    [\n                        13,\n                        17\n                    ]\n                ];\n                p.stroke(r, g, b, 150);\n                p.strokeWeight(2);\n                p.noFill();\n                for (const [start, end] of connections){\n                    if (landmarks[start] && landmarks[end]) {\n                        const startX = landmarks[start].x * p.width - p.width / 2;\n                        const startY = landmarks[start].y * p.height - p.height / 2;\n                        const startZ = landmarks[start].z;\n                        const endX = landmarks[end].x * p.width - p.width / 2;\n                        const endY = landmarks[end].y * p.height - p.height / 2;\n                        const endZ = landmarks[end].z;\n                        p.line(startX, startY, startZ, endX, endY, endZ);\n                    }\n                }\n            }\n            function drawGestureDebug(p) {\n                p.push();\n                p.fill(255);\n                p.textAlign(p.LEFT);\n                p.textSize(14);\n                let yPos = -p.height / 2 + 20;\n                p.text(\"Multi-Hand Gesture Debug:\", -p.width / 2 + 10, yPos);\n                yPos += 20;\n                // Left hand info\n                if (multiHandData.leftHand) {\n                    p.text(\"Left Hand: \".concat(multiHandData.leftHand.gesture, \" (\").concat(Math.round(multiHandData.leftHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Left Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Right hand info\n                if (multiHandData.rightHand) {\n                    p.text(\"Right Hand: \".concat(multiHandData.rightHand.gesture, \" (\").concat(Math.round(multiHandData.rightHand.confidence * 100), \"%)\"), -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                } else {\n                    p.text(\"Right Hand: Not detected\", -p.width / 2 + 10, yPos);\n                    yPos += 15;\n                }\n                // Combined info\n                yPos += 10;\n                const primaryHand = multiHandData.leftHand || multiHandData.rightHand;\n                p.text(\"Primary: \".concat((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.gesture) || \"None\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Confidence: \".concat(Math.round(((primaryHand === null || primaryHand === void 0 ? void 0 : primaryHand.confidence) || 0) * 100), \"%\"), -p.width / 2 + 10, yPos);\n                yPos += 15;\n                p.text(\"Hands Detected: \".concat(multiHandData.totalHands), -p.width / 2 + 10, yPos);\n                p.pop();\n            }\n            function drawPrivacyIndicator(p) {\n                p.push();\n                p.fill(0, 255, 0, 150);\n                p.textAlign(p.RIGHT);\n                p.textSize(12);\n                // Draw privacy indicator in top-right corner\n                p.text(\"Privacy Mode: Hand Tracking Only\", p.width / 2 - 10, -p.height / 2 + 20);\n                p.pop();\n            }\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        multiHandData\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Sketch.tsx\",\n        lineNumber: 345,\n        columnNumber: 10\n    }, this);\n}\n_s(Sketch, \"Zh72f/q+2It/yvCtgIksDCz/hSQ=\");\n_c = Sketch;\nvar _c;\n$RefreshReg$(_c, \"Sketch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NrZXRjaC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFMEM7QUFDdEI7QUFRTCxTQUFTRyxPQUFPLEtBQXdDO1FBQXhDLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFlLEdBQXhDOztJQUM3QixNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUN4QyxNQUFNTyx1QkFBdUJQLDZDQUFNQSxDQUdoQztRQUFFUSxVQUFVO1FBQU1DLFdBQVc7SUFBSztJQUVyQ1YsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNNLFVBQVVLLE9BQU8sRUFBRTtRQUV4QixNQUFNQyxTQUFTLENBQUNDO1lBQ2QsSUFBSUM7WUFDSixJQUFJQyxhQUFhO1lBQ2pCLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyxtQkFBbUI7WUFDdkIsSUFBSUMsV0FBVztZQUNmLElBQUlDLFNBQVM7WUFFYk4sRUFBRU8sS0FBSyxHQUFHO2dCQUNSTixlQUFlRCxFQUFFUSxZQUFZLENBQUMsS0FBSyxHQUFHO2dCQUN0Q1IsRUFBRVMsWUFBWSxDQUFDLEtBQUssS0FBS1QsRUFBRVUsS0FBSztnQkFDaENWLEVBQUVXLFNBQVMsQ0FBQyxLQUFLLHFDQUFxQztnQkFFdEQsaURBQWlEO2dCQUNqRCxJQUFJO29CQUNGWCxFQUFFWSxRQUFRLENBQUM7Z0JBQ2IsRUFBRSxPQUFPQyxPQUFPO29CQUNkQyxRQUFRQyxJQUFJLENBQUMsdUNBQXVDRjtvQkFDcEQsMkJBQTJCO29CQUMzQmIsRUFBRVksUUFBUSxDQUFDO2dCQUNiO2dCQUNBWixFQUFFZ0IsUUFBUSxDQUFDO1lBQ2I7WUFFQWhCLEVBQUVpQixJQUFJLEdBQUc7Z0JBQ1BqQixFQUFFa0IsS0FBSztnQkFDUGxCLEVBQUVtQixJQUFJO2dCQUNObkIsRUFBRW9CLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDbkJwQixFQUFFcUIs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QUMsSUFBSSxJQUFJaUM7Z0JBQzVGQSxRQUFRO2dCQUNSOUUsRUFBRStFLElBQUksQ0FBQyxtQkFBNEMsT0FBekJ4RixjQUFjMkYsVUFBVSxHQUFJLENBQUNsRixFQUFFNkMsS0FBSyxHQUFDLElBQUksSUFBSWlDO2dCQUV2RTlFLEVBQUVxQixHQUFHO1lBQ1A7WUFFQSxTQUFTMkIscUJBQXFCaEQsQ0FBSztnQkFDakNBLEVBQUVtQixJQUFJO2dCQUNObkIsRUFBRStCLElBQUksQ0FBQyxHQUFHLEtBQUssR0FBRztnQkFDbEIvQixFQUFFNEUsU0FBUyxDQUFDNUUsRUFBRW1GLEtBQUs7Z0JBQ25CbkYsRUFBRWdCLFFBQVEsQ0FBQztnQkFFWCw2Q0FBNkM7Z0JBQzdDaEIsRUFBRStFLElBQUksQ0FBQyxvQ0FBb0MvRSxFQUFFNkMsS0FBSyxHQUFDLElBQUksSUFBSSxDQUFDN0MsRUFBRThDLE1BQU0sR0FBQyxJQUFJO2dCQUV6RTlDLEVBQUVxQixHQUFHO1lBQ1A7UUFDRjtRQUVBM0IsY0FBY0ksT0FBTyxHQUFHLElBQUlULDJDQUFFQSxDQUFDVSxRQUFRTixVQUFVSyxPQUFPO1FBRXhELE9BQU87WUFDTCxJQUFJSixjQUFjSSxPQUFPLEVBQUU7Z0JBQ3pCSixjQUFjSSxPQUFPLENBQUNzRixNQUFNO2dCQUM1QjFGLGNBQWNJLE9BQU8sR0FBRztZQUMxQjtRQUNGO0lBQ0YsR0FBRztRQUFDUDtLQUFjO0lBRWxCLHFCQUFPLDhEQUFDOEY7UUFBSUMsS0FBSzdGOzs7Ozs7QUFDbkI7R0E5VXdCSDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Ta2V0Y2gudHN4PzM3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBwNSBmcm9tICdwNSc7XG5pbXBvcnQgeyBNdWx0aUhhbmREYXRhIH0gZnJvbSAnQC90eXBlcyc7XG5cbmludGVyZmFjZSBTa2V0Y2hQcm9wcyB7XG4gIG11bHRpSGFuZERhdGE6IE11bHRpSGFuZERhdGE7XG4gIHZpZGVvUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTFZpZGVvRWxlbWVudD47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNrZXRjaCh7IG11bHRpSGFuZERhdGEsIHZpZGVvUmVmIH06IFNrZXRjaFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHA1SW5zdGFuY2VSZWYgPSB1c2VSZWY8cDUgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgc21vb3RoZWRMYW5kbWFya3NSZWYgPSB1c2VSZWY8e1xuICAgIGxlZnRIYW5kOiBhbnlbXSB8IG51bGw7XG4gICAgcmlnaHRIYW5kOiBhbnlbXSB8IG51bGw7XG4gIH0+KHsgbGVmdEhhbmQ6IG51bGwsIHJpZ2h0SGFuZDogbnVsbCB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHNrZXRjaCA9IChwOiBwNSkgPT4ge1xuICAgICAgbGV0IG9iamVjdFZlY3RvcjogcDUuVmVjdG9yO1xuICAgICAgbGV0IG9iamVjdFNpemUgPSAxO1xuICAgICAgbGV0IGxhc3RPYmplY3RTaXplID0gMTtcbiAgICAgIGxldCBvYmplY3RTaXplU21vb3RoID0gMDtcbiAgICAgIGxldCBncmFiYmluZyA9IGZhbHNlO1xuICAgICAgbGV0IGxvY2tlZCA9IGZhbHNlO1xuXG4gICAgICBwLnNldHVwID0gKCkgPT4ge1xuICAgICAgICBvYmplY3RWZWN0b3IgPSBwLmNyZWF0ZVZlY3RvcigxMDAsIDAsIDApO1xuICAgICAgICBwLmNyZWF0ZUNhbnZhcyg4MDAsIDY0MCwgcC5XRUJHTCk7XG4gICAgICAgIHAuZnJhbWVSYXRlKDYwKTsgLy8gU2V0IHRvIDYwIEZQUyBmb3Igc21vb3RoIHJlbmRlcmluZ1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHN5c3RlbSBmb250IGluc3RlYWQgb2YgbG9hZGluZyBjdXN0b20gZm9udFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHAudGV4dEZvbnQoJ3N5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgc2Fucy1zZXJpZicpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRm9udCBsb2FkaW5nIGZhaWxlZCwgdXNpbmcgZGVmYXVsdDonLCBlcnJvcik7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBmb250XG4gICAgICAgICAgcC50ZXh0Rm9udCgnQXJpYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBwLnRleHRTaXplKDEyKTtcbiAgICAgIH07XG5cbiAgICAgIHAuZHJhdyA9ICgpID0+IHtcbiAgICAgICAgcC5jbGVhcigpO1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC50cmFuc2xhdGUoMCwgMCwgLTEwMCk7XG4gICAgICAgIHAucG9wKCk7XG5cbiAgICAgICAgLy8gRW5oYW5jZWQgZ2VzdHVyZSBkaXNwbGF5XG4gICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29sb3IgYmFzZWQgb24gZ2VzdHVyZSB0eXBlICh1c2luZyBwcmltYXJ5IGhhbmQpXG4gICAgICAgIGxldCBnZXN0dXJlQ29sb3I7XG4gICAgICAgIGNvbnN0IHByaW1hcnlIYW5kID0gbXVsdGlIYW5kRGF0YS5sZWZ0SGFuZCB8fCBtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcmltYXJ5SGFuZCkge1xuICAgICAgICAgIHN3aXRjaChwcmltYXJ5SGFuZC5nZXN0dXJlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGluY2hcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigyNTUsIDAsIDApOyAvLyBSZWRcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlzdFwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDI1NSwgMTY1LCAwKTsgLy8gT3JhbmdlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wZW5IYW5kXCI6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMCwgMjU1LCAwKTsgLy8gR3JlZW5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicG9pbnRpbmdcIjpcbiAgICAgICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigwLCAyNTUsIDI1NSk7IC8vIEN5YW5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmljdG9yeVwiOlxuICAgICAgICAgICAgICBnZXN0dXJlQ29sb3IgPSBwLmNvbG9yKDI1NSwgMCwgMjU1KTsgLy8gTWFnZW50YVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGdlc3R1cmVDb2xvciA9IHAuY29sb3IoMTI4LCAxMjgsIDEyOCk7IC8vIEdyYXlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VzdHVyZUNvbG9yID0gcC5jb2xvcigxMjgsIDEyOCwgMTI4KTsgLy8gR3JheVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwLnN0cm9rZShnZXN0dXJlQ29sb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBnZXN0dXJlIGluZGljYXRvciBsaW5lXG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBwcmltYXJ5SGFuZCA/IHByaW1hcnlIYW5kLmNvbmZpZGVuY2UgKiAzMDAgOiAwO1xuICAgICAgICBwLmxpbmUoMCwgMCwgbGluZUxlbmd0aCwgMCk7XG5cbiAgICAgICAgLy8gRHJhdyBvYmplY3Qgd2hpY2ggaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKDAsIDAsIDI1NSwgMTAwKTtcbiAgICAgICAgcC5zdHJva2UoMCwgMCwgMjU1KTtcbiAgICAgICAgcC50cmFuc2xhdGUob2JqZWN0VmVjdG9yLngsIG9iamVjdFZlY3Rvci55LCBvYmplY3RWZWN0b3Iueik7XG4gICAgICAgIHAuZWxsaXBzZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMTAwICogcC5tYXAob2JqZWN0VmVjdG9yLnosIDAuMSwgLTAuMSwgMC4xLCBvYmplY3RTaXplU21vb3RoKSxcbiAgICAgICAgICAxMDAgKiBwLm1hcChvYmplY3RWZWN0b3IueiwgMC4xLCAtMC4xLCAwLjEsIG9iamVjdFNpemVTbW9vdGgpXG4gICAgICAgICk7XG4gICAgICAgIHAucG9wKCk7XG5cbiAgICAgICAgLy8gRHJhdyBsYW5kbWFya3NcbiAgICAgICAgZGlzcGxheVJlc3VsdHMocCk7XG5cbiAgICAgICAgLy8gRW5oYW5jZWQgZ2VzdHVyZS1iYXNlZCBpbnRlcmFjdGlvblxuICAgICAgICBpZiAocHJpbWFyeUhhbmQ/Lmdlc3R1cmUgPT09IFwicGluY2hcIikge1xuICAgICAgICAgIGdyYWJiaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFiYmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGdyYWJiaW5nIGludGVyYWN0aW9uIHdpdGggdGhlIG9iamVjdFxuICAgICAgICBpZiAoZ3JhYmJpbmcgJiYgcHJpbWFyeUhhbmQpIHtcbiAgICAgICAgICAvLyBVc2UgdGh1bWIgdGlwICg0KSBhbmQgaW5kZXggdGlwICg4KSBmb3IgcGluY2ggcG9zaXRpb25cbiAgICAgICAgICBjb25zdCB0aHVtYlRpcCA9IHByaW1hcnlIYW5kLmxhbmRtYXJrc1s0XTtcbiAgICAgICAgICBjb25zdCBpbmRleFRpcCA9IHByaW1hcnlIYW5kLmxhbmRtYXJrc1s4XTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcGluY2ggY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgY29uc3QgcGluY2hYID0gKHRodW1iVGlwLnggKyBpbmRleFRpcC54KSAvIDI7XG4gICAgICAgICAgY29uc3QgcGluY2hZID0gKHRodW1iVGlwLnkgKyBpbmRleFRpcC55KSAvIDI7XG4gICAgICAgICAgY29uc3QgcGluY2haID0gKHRodW1iVGlwLnogKyBpbmRleFRpcC56KSAvIDI7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFwIHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgbGV0IHBpbmNoVmVjdG9yID0gcC5jcmVhdGVWZWN0b3IoXG4gICAgICAgICAgICBwaW5jaFggKiBwLndpZHRoIC0gcC53aWR0aCAvIDIsXG4gICAgICAgICAgICBwaW5jaFkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHBpbmNoWlxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcC5kaXN0KHBpbmNoVmVjdG9yLngsIHBpbmNoVmVjdG9yLnksIG9iamVjdFZlY3Rvci54LCBvYmplY3RWZWN0b3IueSkgPCA1MCAmJlxuICAgICAgICAgICAgbG9ja2VkID09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgb2JqZWN0U2l6ZSA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci54ID0gcGluY2hWZWN0b3IueDtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci55ID0gcGluY2hWZWN0b3IueTtcbiAgICAgICAgICAgIG9iamVjdFZlY3Rvci56ID0gcGluY2hWZWN0b3IuejtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgb2JqZWN0U2l6ZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbW9vdGggb2JqZWN0IHNpemVcbiAgICAgICAgb2JqZWN0U2l6ZVNtb290aCA9IG9iamVjdFNpemUgKiAwLjUgKyBsYXN0T2JqZWN0U2l6ZSAqIDAuNTtcbiAgICAgICAgbGFzdE9iamVjdFNpemUgPSBvYmplY3RTaXplU21vb3RoO1xuXG4gICAgICAgIC8vIERyYXcgcHJpdmFjeSBpbmRpY2F0b3Igb25seVxuICAgICAgICBkcmF3UHJpdmFjeUluZGljYXRvcihwKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEVuaGFuY2VkIHNtb290aGluZyB3aXRoIHBlcnNpc3RlbmNlXG4gICAgICBjb25zdCBzbW9vdGhMYW5kbWFya3MgPSAoY3VycmVudExhbmRtYXJrczogYW55W10sIHByZXZpb3VzTGFuZG1hcmtzOiBhbnlbXSB8IG51bGwsIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyID0gMC4yKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudExhbmRtYXJrcyB8fCBjdXJyZW50TGFuZG1hcmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBwcmV2aW91c0xhbmRtYXJrczsgLy8gS2VlcCBwcmV2aW91cyBsYW5kbWFya3MgaWYgbm8gbmV3IG9uZXNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFwcmV2aW91c0xhbmRtYXJrcyB8fCBwcmV2aW91c0xhbmRtYXJrcy5sZW5ndGggIT09IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMYW5kbWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjdXJyZW50TGFuZG1hcmtzLm1hcCgobGFuZG1hcmssIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHByZXZpb3VzTGFuZG1hcmtzW2luZGV4XTtcbiAgICAgICAgICBpZiAoIXByZXYpIHJldHVybiBsYW5kbWFyaztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNb3JlIGFnZ3Jlc3NpdmUgc21vb3RoaW5nIGZvciBzdGFiaWxpdHlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcHJldi54ICsgKGxhbmRtYXJrLnggLSBwcmV2LngpICogc21vb3RoaW5nRmFjdG9yLFxuICAgICAgICAgICAgeTogcHJldi55ICsgKGxhbmRtYXJrLnkgLSBwcmV2LnkpICogc21vb3RoaW5nRmFjdG9yLFxuICAgICAgICAgICAgejogcHJldi56ICsgKGxhbmRtYXJrLnogLSBwcmV2LnopICogc21vb3RoaW5nRmFjdG9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBkaXNwbGF5UmVzdWx0cyhwOiBwNSkge1xuICAgICAgICAvLyBTbW9vdGggbGVmdCBoYW5kIGxhbmRtYXJrc1xuICAgICAgICBpZiAobXVsdGlIYW5kRGF0YS5sZWZ0SGFuZCkge1xuICAgICAgICAgIGNvbnN0IHNtb290aGVkTGVmdCA9IHNtb290aExhbmRtYXJrcyhcbiAgICAgICAgICAgIG11bHRpSGFuZERhdGEubGVmdEhhbmQubGFuZG1hcmtzLCBcbiAgICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQubGVmdEhhbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQubGVmdEhhbmQgPSBzbW9vdGhlZExlZnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBsZWZ0IGhhbmQgbGFuZG1hcmtzIChncmVlbilcbiAgICAgICAgICBwLnN0cm9rZSgwLCAyNTUsIDApOyAvLyBHcmVlbiBmb3IgbGVmdCBoYW5kXG4gICAgICAgICAgcC5zdHJva2VXZWlnaHQoNCk7XG4gICAgICAgICAgcC5maWxsKDAsIDI1NSwgMCwgMTAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zIGJldHdlZW4gbGFuZG1hcmtzIGZvciBiZXR0ZXIgdmlzdWFsaXphdGlvblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc21vb3RoZWRMZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsYW5kbWFyayA9IHNtb290aGVkTGVmdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBsYW5kbWFyay54ICogcC53aWR0aCAtIHAud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgeSA9IGxhbmRtYXJrLnkgKiBwLmhlaWdodCAtIHAuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHogPSBsYW5kbWFyay56O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEcmF3IGxhbmRtYXJrIHBvaW50XG4gICAgICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgICAgIHAudHJhbnNsYXRlKHgsIHksIHopO1xuICAgICAgICAgICAgcC5zcGhlcmUoMyk7XG4gICAgICAgICAgICBwLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IGhhbmQgY29ubmVjdGlvbnMgKGZpbmdlciBib25lcylcbiAgICAgICAgICBkcmF3SGFuZENvbm5lY3Rpb25zKHAsIHNtb290aGVkTGVmdCwgMCwgMjU1LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbW9vdGhlZExhbmRtYXJrc1JlZi5jdXJyZW50LmxlZnRIYW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU21vb3RoIHJpZ2h0IGhhbmQgbGFuZG1hcmtzXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZCkge1xuICAgICAgICAgIGNvbnN0IHNtb290aGVkUmlnaHQgPSBzbW9vdGhMYW5kbWFya3MoXG4gICAgICAgICAgICBtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZC5sYW5kbWFya3MsIFxuICAgICAgICAgICAgc21vb3RoZWRMYW5kbWFya3NSZWYuY3VycmVudC5yaWdodEhhbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQucmlnaHRIYW5kID0gc21vb3RoZWRSaWdodDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHJpZ2h0IGhhbmQgbGFuZG1hcmtzIChibHVlKVxuICAgICAgICAgIHAuc3Ryb2tlKDAsIDAsIDI1NSk7IC8vIEJsdWUgZm9yIHJpZ2h0IGhhbmRcbiAgICAgICAgICBwLnN0cm9rZVdlaWdodCg0KTtcbiAgICAgICAgICBwLmZpbGwoMCwgMCwgMjU1LCAxMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERyYXcgY29ubmVjdGlvbnMgYmV0d2VlbiBsYW5kbWFya3MgZm9yIGJldHRlciB2aXN1YWxpemF0aW9uXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbW9vdGhlZFJpZ2h0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsYW5kbWFyayA9IHNtb290aGVkUmlnaHRbaV07XG4gICAgICAgICAgICBjb25zdCB4ID0gbGFuZG1hcmsueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBsYW5kbWFyay55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCB6ID0gbGFuZG1hcmsuejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyBsYW5kbWFyayBwb2ludFxuICAgICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgICBwLnRyYW5zbGF0ZSh4LCB5LCB6KTtcbiAgICAgICAgICAgIHAuc3BoZXJlKDMpO1xuICAgICAgICAgICAgcC5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBoYW5kIGNvbm5lY3Rpb25zIChmaW5nZXIgYm9uZXMpXG4gICAgICAgICAgZHJhd0hhbmRDb25uZWN0aW9ucyhwLCBzbW9vdGhlZFJpZ2h0LCAwLCAwLCAyNTUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtb290aGVkTGFuZG1hcmtzUmVmLmN1cnJlbnQucmlnaHRIYW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3SGFuZENvbm5lY3Rpb25zKHA6IHA1LCBsYW5kbWFya3M6IGFueVtdLCByOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gICAgICAgIC8vIE1lZGlhUGlwZSBoYW5kIGNvbm5lY3Rpb25zIChmaW5nZXIgYm9uZXMpXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW1xuICAgICAgICAgIC8vIFRodW1iXG4gICAgICAgICAgWzAsIDFdLCBbMSwgMl0sIFsyLCAzXSwgWzMsIDRdLFxuICAgICAgICAgIC8vIEluZGV4IGZpbmdlclxuICAgICAgICAgIFswLCA1XSwgWzUsIDZdLCBbNiwgN10sIFs3LCA4XSxcbiAgICAgICAgICAvLyBNaWRkbGUgZmluZ2VyXG4gICAgICAgICAgWzAsIDldLCBbOSwgMTBdLCBbMTAsIDExXSwgWzExLCAxMl0sXG4gICAgICAgICAgLy8gUmluZyBmaW5nZXJcbiAgICAgICAgICBbMCwgMTNdLCBbMTMsIDE0XSwgWzE0LCAxNV0sIFsxNSwgMTZdLFxuICAgICAgICAgIC8vIFBpbmt5XG4gICAgICAgICAgWzAsIDE3XSwgWzE3LCAxOF0sIFsxOCwgMTldLCBbMTksIDIwXSxcbiAgICAgICAgICAvLyBQYWxtIGNvbm5lY3Rpb25zXG4gICAgICAgICAgWzUsIDldLCBbOSwgMTNdLCBbMTMsIDE3XVxuICAgICAgICBdO1xuXG4gICAgICAgIHAuc3Ryb2tlKHIsIGcsIGIsIDE1MCk7XG4gICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDIpO1xuICAgICAgICBwLm5vRmlsbCgpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKGxhbmRtYXJrc1tzdGFydF0gJiYgbGFuZG1hcmtzW2VuZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IGxhbmRtYXJrc1tzdGFydF0ueCAqIHAud2lkdGggLSBwLndpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGxhbmRtYXJrc1tzdGFydF0ueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRaID0gbGFuZG1hcmtzW3N0YXJ0XS56O1xuICAgICAgICAgICAgY29uc3QgZW5kWCA9IGxhbmRtYXJrc1tlbmRdLnggKiBwLndpZHRoIC0gcC53aWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBlbmRZID0gbGFuZG1hcmtzW2VuZF0ueSAqIHAuaGVpZ2h0IC0gcC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3QgZW5kWiA9IGxhbmRtYXJrc1tlbmRdLno7XG5cbiAgICAgICAgICAgIHAubGluZShzdGFydFgsIHN0YXJ0WSwgc3RhcnRaLCBlbmRYLCBlbmRZLCBlbmRaKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd0dlc3R1cmVEZWJ1ZyhwOiBwNSkge1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKDI1NSk7XG4gICAgICAgIHAudGV4dEFsaWduKHAuTEVGVCk7XG4gICAgICAgIHAudGV4dFNpemUoMTQpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHlQb3MgPSAtcC5oZWlnaHQvMiArIDIwO1xuICAgICAgICBwLnRleHQoXCJNdWx0aS1IYW5kIEdlc3R1cmUgRGVidWc6XCIsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgIHlQb3MgKz0gMjA7XG4gICAgICAgIFxuICAgICAgICAvLyBMZWZ0IGhhbmQgaW5mb1xuICAgICAgICBpZiAobXVsdGlIYW5kRGF0YS5sZWZ0SGFuZCkge1xuICAgICAgICAgIHAudGV4dChgTGVmdCBIYW5kOiAke211bHRpSGFuZERhdGEubGVmdEhhbmQuZ2VzdHVyZX0gKCR7TWF0aC5yb3VuZChtdWx0aUhhbmREYXRhLmxlZnRIYW5kLmNvbmZpZGVuY2UgKiAxMDApfSUpYCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudGV4dChcIkxlZnQgSGFuZDogTm90IGRldGVjdGVkXCIsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgICAgeVBvcyArPSAxNTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmlnaHQgaGFuZCBpbmZvXG4gICAgICAgIGlmIChtdWx0aUhhbmREYXRhLnJpZ2h0SGFuZCkge1xuICAgICAgICAgIHAudGV4dChgUmlnaHQgSGFuZDogJHttdWx0aUhhbmREYXRhLnJpZ2h0SGFuZC5nZXN0dXJlfSAoJHtNYXRoLnJvdW5kKG11bHRpSGFuZERhdGEucmlnaHRIYW5kLmNvbmZpZGVuY2UgKiAxMDApfSUpYCwgLXAud2lkdGgvMiArIDEwLCB5UG9zKTtcbiAgICAgICAgICB5UG9zICs9IDE1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudGV4dChcIlJpZ2h0IEhhbmQ6IE5vdCBkZXRlY3RlZFwiLCAtcC53aWR0aC8yICsgMTAsIHlQb3MpO1xuICAgICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENvbWJpbmVkIGluZm9cbiAgICAgICAgeVBvcyArPSAxMDtcbiAgICAgICAgY29uc3QgcHJpbWFyeUhhbmQgPSBtdWx0aUhhbmREYXRhLmxlZnRIYW5kIHx8IG11bHRpSGFuZERhdGEucmlnaHRIYW5kO1xuICAgICAgICBwLnRleHQoYFByaW1hcnk6ICR7cHJpbWFyeUhhbmQ/Lmdlc3R1cmUgfHwgJ05vbmUnfWAsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIHAudGV4dChgQ29uZmlkZW5jZTogJHtNYXRoLnJvdW5kKChwcmltYXJ5SGFuZD8uY29uZmlkZW5jZSB8fCAwKSAqIDEwMCl9JWAsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgIHlQb3MgKz0gMTU7XG4gICAgICAgIHAudGV4dChgSGFuZHMgRGV0ZWN0ZWQ6ICR7bXVsdGlIYW5kRGF0YS50b3RhbEhhbmRzfWAsIC1wLndpZHRoLzIgKyAxMCwgeVBvcyk7XG4gICAgICAgIFxuICAgICAgICBwLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3UHJpdmFjeUluZGljYXRvcihwOiBwNSkge1xuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC5maWxsKDAsIDI1NSwgMCwgMTUwKTtcbiAgICAgICAgcC50ZXh0QWxpZ24ocC5SSUdIVCk7XG4gICAgICAgIHAudGV4dFNpemUoMTIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBwcml2YWN5IGluZGljYXRvciBpbiB0b3AtcmlnaHQgY29ybmVyXG4gICAgICAgIHAudGV4dChcIlByaXZhY3kgTW9kZTogSGFuZCBUcmFja2luZyBPbmx5XCIsIHAud2lkdGgvMiAtIDEwLCAtcC5oZWlnaHQvMiArIDIwKTtcbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyBwNShza2V0Y2gsIGNhbnZhc1JlZi5jdXJyZW50KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocDVJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbXVsdGlIYW5kRGF0YV0pO1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y2FudmFzUmVmfSAvPjtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInA1IiwiU2tldGNoIiwibXVsdGlIYW5kRGF0YSIsInZpZGVvUmVmIiwiY2FudmFzUmVmIiwicDVJbnN0YW5jZVJlZiIsInNtb290aGVkTGFuZG1hcmtzUmVmIiwibGVmdEhhbmQiLCJyaWdodEhhbmQiLCJjdXJyZW50Iiwic2tldGNoIiwicCIsIm9iamVjdFZlY3RvciIsIm9iamVjdFNpemUiLCJsYXN0T2JqZWN0U2l6ZSIsIm9iamVjdFNpemVTbW9vdGgiLCJncmFiYmluZyIsImxvY2tlZCIsInNldHVwIiwiY3JlYXRlVmVjdG9yIiwiY3JlYXRlQ2FudmFzIiwiV0VCR0wiLCJmcmFtZVJhdGUiLCJ0ZXh0Rm9udCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJ0ZXh0U2l6ZSIsImRyYXciLCJjbGVhciIsInB1c2giLCJ0cmFuc2xhdGUiLCJwb3AiLCJzdHJva2VXZWlnaHQiLCJnZXN0dXJlQ29sb3IiLCJwcmltYXJ5SGFuZCIsImdlc3R1cmUiLCJjb2xvciIsInN0cm9rZSIsImxpbmVMZW5ndGgiLCJjb25maWRlbmNlIiwibGluZSIsImZpbGwiLCJ4IiwieSIsInoiLCJlbGxpcHNlIiwibWFwIiwiZGlzcGxheVJlc3VsdHMiLCJ0aHVtYlRpcCIsImxhbmRtYXJrcyIsImluZGV4VGlwIiwicGluY2hYIiwicGluY2hZIiwicGluY2haIiwicGluY2hWZWN0b3IiLCJ3aWR0aCIsImhlaWdodCIsImRpc3QiLCJkcmF3UHJpdmFjeUluZGljYXRvciIsInNtb290aExhbmRtYXJrcyIsImN1cnJlbnRMYW5kbWFya3MiLCJwcmV2aW91c0xhbmRtYXJrcyIsInNtb290aGluZ0ZhY3RvciIsImxlbmd0aCIsImxhbmRtYXJrIiwiaW5kZXgiLCJwcmV2Iiwic21vb3RoZWRMZWZ0IiwiaSIsInNwaGVyZSIsImRyYXdIYW5kQ29ubmVjdGlvbnMiLCJzbW9vdGhlZFJpZ2h0IiwiciIsImciLCJiIiwiY29ubmVjdGlvbnMiLCJub0ZpbGwiLCJzdGFydCIsImVuZCIsInN0YXJ0WCIsInN0YXJ0WSIsInN0YXJ0WiIsImVuZFgiLCJlbmRZIiwiZW5kWiIsImRyYXdHZXN0dXJlRGVidWciLCJ0ZXh0QWxpZ24iLCJMRUZUIiwieVBvcyIsInRleHQiLCJNYXRoIiwicm91bmQiLCJ0b3RhbEhhbmRzIiwiUklHSFQiLCJyZW1vdmUiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Sketch.tsx\n"));

/***/ })

});
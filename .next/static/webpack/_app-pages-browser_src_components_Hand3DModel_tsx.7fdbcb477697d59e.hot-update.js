"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Hand3DModel_tsx",{

/***/ "(app-pages-browser)/./src/components/Hand3DModel.tsx":
/*!****************************************!*\
  !*** ./src/components/Hand3DModel.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Hand3DModel; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p5 */ \"(app-pages-browser)/./node_modules/p5/lib/p5.min.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction Hand3DModel(param) {\n    let { leftHand, rightHand } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const p5InstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Smoothing and stabilization refs\n    const previousLeftHand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const previousRightHand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const velocityLeft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const velocityRight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const frameCount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current) return;\n        const sketch = (p)=>{\n            let handTexture;\n            p.preload = ()=>{\n                // Create a realistic hand texture programmatically\n                handTexture = p.createImage(128, 128);\n                handTexture.loadPixels();\n                for(let y = 0; y < handTexture.height; y++){\n                    for(let x = 0; x < handTexture.width; x++){\n                        const index = (y * handTexture.width + x) * 4;\n                        // Create skin-like color with variation\n                        const baseR = 255;\n                        const baseG = 200 + Math.sin(x * 0.1) * 20;\n                        const baseB = 150 + Math.cos(y * 0.1) * 15;\n                        // Add some texture variation\n                        const noise = Math.sin(x * 0.05) * Math.cos(y * 0.05) * 10;\n                        handTexture.pixels[index] = Math.max(200, Math.min(255, baseR + noise)); // R\n                        handTexture.pixels[index + 1] = Math.max(180, Math.min(220, baseG + noise)); // G\n                        handTexture.pixels[index + 2] = Math.max(140, Math.min(170, baseB + noise)); // B\n                        handTexture.pixels[index + 3] = 255; // A\n                    }\n                }\n                handTexture.updatePixels();\n            };\n            p.setup = ()=>{\n                p.createCanvas(800, 640, p.WEBGL);\n                p.frameRate(30); // Lower frame rate for stability\n            };\n            p.draw = ()=>{\n                p.clear();\n                p.push();\n                p.translate(0, 0, -100);\n                // Set up lighting\n                p.ambientLight(60, 60, 60);\n                p.directionalLight(255, 255, 255, 0, 0, -1);\n                p.pointLight(255, 255, 255, 0, 0, 0);\n                // Apply smoothing to landmarks\n                let smoothedLeftLandmarks = null;\n                let smoothedRightLandmarks = null;\n                if (leftHand) {\n                    smoothedLeftLandmarks = smoothLandmarks(leftHand.landmarks, previousLeftHand.current, velocityLeft.current, 0.25);\n                    previousLeftHand.current = smoothedLeftLandmarks;\n                }\n                if (rightHand) {\n                    smoothedRightLandmarks = smoothLandmarks(rightHand.landmarks, previousRightHand.current, velocityRight.current, 0.25);\n                    previousRightHand.current = smoothedRightLandmarks;\n                }\n                // Render left hand with smoothed landmarks\n                if (smoothedLeftLandmarks) {\n                    renderHand3D(p, smoothedLeftLandmarks, [\n                        0,\n                        255,\n                        0\n                    ], \"left\");\n                }\n                // Render right hand with smoothed landmarks\n                if (smoothedRightLandmarks) {\n                    renderHand3D(p, smoothedRightLandmarks, [\n                        0,\n                        0,\n                        255\n                    ], \"right\");\n                }\n                p.pop();\n            };\n            const renderHand3D = (p, landmarks, color, handType)=>{\n                if (!landmarks || landmarks.length < 21) return;\n                p.push();\n                // Calculate hand center and orientation\n                const handCenter = calculateHandCenter(landmarks);\n                const handRotation = calculateHandRotation(landmarks);\n                const handScale = calculateHandScale(landmarks);\n                // Transform to hand position with stable coordinate mapping\n                const screenX = -handCenter.x * p.width + p.width / 2;\n                const screenY = handCenter.y * p.height - p.height / 2;\n                const screenZ = handCenter.z * 50; // Reduced depth for stability\n                p.translate(screenX, screenY, screenZ);\n                p.rotateX(handRotation.x);\n                p.rotateY(handRotation.y);\n                p.rotateZ(handRotation.z);\n                p.scale(handScale);\n                // Render palm with texture\n                renderPalm(p, landmarks, color);\n                // Render fingers with texture\n                renderFingers(p, landmarks, color);\n                p.pop();\n            };\n            const calculateHandCenter = (landmarks)=>{\n                // Use wrist (landmark 0) as center\n                return {\n                    x: landmarks[0].x,\n                    y: landmarks[0].y,\n                    z: landmarks[0].z\n                };\n            };\n            const calculateHandRotation = (landmarks)=>{\n                // Calculate hand orientation based on palm landmarks\n                const wrist = landmarks[0];\n                const middleFinger = landmarks[12];\n                const indexFinger = landmarks[8];\n                // Calculate palm normal\n                const palmNormal = p.createVector(middleFinger.x - wrist.x, middleFinger.y - wrist.y, middleFinger.z - wrist.z);\n                return {\n                    x: Math.atan2(palmNormal.y, palmNormal.z),\n                    y: Math.atan2(palmNormal.x, palmNormal.z),\n                    z: Math.atan2(palmNormal.y, palmNormal.x)\n                };\n            };\n            const calculateHandScale = (landmarks)=>{\n                // Calculate hand size based on palm width\n                const wrist = landmarks[0];\n                const pinky = landmarks[17];\n                const thumb = landmarks[4];\n                const palmWidth = Math.abs(pinky.x - thumb.x);\n                return Math.max(0.5, Math.min(2.0, palmWidth * 10));\n            };\n            const renderPalm = (p, landmarks, color)=>{\n                // Create palm using textured spheres at key points\n                const palmLandmarks = [\n                    0,\n                    5,\n                    9,\n                    13,\n                    17\n                ]; // Wrist and finger bases\n                p.push();\n                p.texture(handTexture);\n                p.noStroke();\n                // Draw palm center with texture\n                const wrist = landmarks[0];\n                const palmCenter = {\n                    x: (wrist.x - 0.5) * 2,\n                    y: (wrist.y - 0.5) * 2,\n                    z: wrist.z\n                };\n                p.push();\n                p.translate(palmCenter.x, palmCenter.y, palmCenter.z);\n                p.fill(255, 200, 150, 200); // Skin color\n                p.sphere(0.08);\n                p.pop();\n                // Draw palm joints with texture\n                for(let i = 1; i < palmLandmarks.length; i++){\n                    const landmark = landmarks[palmLandmarks[i]];\n                    const x = (landmark.x - 0.5) * 2;\n                    const y = (landmark.y - 0.5) * 2;\n                    const z = landmark.z;\n                    p.push();\n                    p.translate(x, y, z);\n                    p.fill(255, 200, 150, 180); // Skin color\n                    p.sphere(0.05);\n                    p.pop();\n                }\n                // Draw palm connections with skin color\n                p.noFill();\n                p.stroke(255, 200, 150, 120);\n                p.strokeWeight(4);\n                for(let i = 0; i < palmLandmarks.length - 1; i++){\n                    const current = landmarks[palmLandmarks[i]];\n                    const next = landmarks[palmLandmarks[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n            const renderFingers = (p, landmarks, color)=>{\n                // Finger landmark indices\n                const fingerIndices = [\n                    [\n                        4,\n                        3,\n                        2,\n                        1,\n                        0\n                    ],\n                    [\n                        8,\n                        7,\n                        6,\n                        5\n                    ],\n                    [\n                        12,\n                        11,\n                        10,\n                        9\n                    ],\n                    [\n                        16,\n                        15,\n                        14,\n                        13\n                    ],\n                    [\n                        20,\n                        19,\n                        18,\n                        17\n                    ] // Pinky\n                ];\n                fingerIndices.forEach((finger, fingerIndex)=>{\n                    renderFinger(p, landmarks, finger, color, fingerIndex);\n                });\n            };\n            const renderFinger = (p, landmarks, fingerIndices, color, fingerIndex)=>{\n                p.push();\n                p.texture(handTexture);\n                // Draw finger joints as textured spheres\n                for(let i = 0; i < fingerIndices.length; i++){\n                    const landmark = landmarks[fingerIndices[i]];\n                    const x = (landmark.x - 0.5) * 2;\n                    const y = (landmark.y - 0.5) * 2;\n                    const z = landmark.z;\n                    p.push();\n                    p.translate(x, y, z);\n                    const jointSize = 0.025 * (1 - i * 0.1); // Smaller towards tip\n                    p.fill(255, 200, 150, 200); // Skin color\n                    p.sphere(jointSize);\n                    p.pop();\n                }\n                // Draw finger connections with skin color\n                p.noFill();\n                p.stroke(255, 200, 150, 150);\n                p.strokeWeight(3);\n                for(let i = 0; i < fingerIndices.length - 1; i++){\n                    const current = landmarks[fingerIndices[i]];\n                    const next = landmarks[fingerIndices[i + 1]];\n                    const x1 = (current.x - 0.5) * 2;\n                    const y1 = (current.y - 0.5) * 2;\n                    const z1 = current.z;\n                    const x2 = (next.x - 0.5) * 2;\n                    const y2 = (next.y - 0.5) * 2;\n                    const z2 = next.z;\n                    p.line(x1, y1, z1, x2, y2, z2);\n                }\n                p.pop();\n            };\n        };\n        p5InstanceRef.current = new (p5__WEBPACK_IMPORTED_MODULE_2___default())(sketch, canvasRef.current);\n        return ()=>{\n            if (p5InstanceRef.current) {\n                p5InstanceRef.current.remove();\n                p5InstanceRef.current = null;\n            }\n        };\n    }, [\n        leftHand,\n        rightHand\n    ]);\n    // Smoothing function with velocity-based interpolation\n    const smoothLandmarks = function(currentLandmarks, previousLandmarks, velocities) {\n        let smoothingFactor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.3;\n        if (!currentLandmarks || currentLandmarks.length === 0) {\n            return previousLandmarks;\n        }\n        if (!previousLandmarks || previousLandmarks.length !== currentLandmarks.length) {\n            // Initialize velocities\n            velocities.length = currentLandmarks.length;\n            for(let i = 0; i < currentLandmarks.length; i++){\n                velocities[i] = {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                };\n            }\n            return currentLandmarks;\n        }\n        const smoothedLandmarks = [];\n        for(let i = 0; i < currentLandmarks.length; i++){\n            const current = currentLandmarks[i];\n            const previous = previousLandmarks[i];\n            const velocity = velocities[i];\n            // Calculate velocity (change in position)\n            const deltaX = current.x - previous.x;\n            const deltaY = current.y - previous.y;\n            const deltaZ = current.z - previous.z;\n            // Update velocity with smoothing\n            velocity.x = velocity.x * 0.8 + deltaX * 0.2;\n            velocity.y = velocity.y * 0.8 + deltaY * 0.2;\n            velocity.z = velocity.z * 0.8 + deltaZ * 0.2;\n            // Apply velocity-based smoothing\n            const smoothedX = previous.x + velocity.x * smoothingFactor;\n            const smoothedY = previous.y + velocity.y * smoothingFactor;\n            const smoothedZ = previous.z + velocity.z * smoothingFactor;\n            // Clamp to prevent extreme values\n            const clampedX = Math.max(0, Math.min(1, smoothedX));\n            const clampedY = Math.max(0, Math.min(1, smoothedY));\n            const clampedZ = Math.max(-1, Math.min(1, smoothedZ));\n            smoothedLandmarks.push({\n                x: clampedX,\n                y: clampedY,\n                z: clampedZ\n            });\n        }\n        return smoothedLandmarks;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: canvasRef\n    }, void 0, false, {\n        fileName: \"/Users/JoaquinNam/Desktop/MENTE_MAESTRA/web3/GCMND/src/components/Hand3DModel.tsx\",\n        lineNumber: 345,\n        columnNumber: 10\n    }, this);\n}\n_s(Hand3DModel, \"hQofq7RbjNpzPDDyEHkNZNeXNGI=\");\n_c = Hand3DModel;\nvar _c;\n$RefreshReg$(_c, \"Hand3DModel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hhbmQzRE1vZGVsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUwQztBQUN0QjtBQVFMLFNBQVNHLFlBQVksS0FBeUM7UUFBekMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQW9CLEdBQXpDOztJQUNsQyxNQUFNQyxZQUFZTCw2Q0FBTUEsQ0FBaUI7SUFDekMsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBWTtJQUV4QyxtQ0FBbUM7SUFDbkMsTUFBTU8sbUJBQW1CUCw2Q0FBTUEsQ0FBZTtJQUM5QyxNQUFNUSxvQkFBb0JSLDZDQUFNQSxDQUFlO0lBQy9DLE1BQU1TLGVBQWVULDZDQUFNQSxDQUFRLEVBQUU7SUFDckMsTUFBTVUsZ0JBQWdCViw2Q0FBTUEsQ0FBUSxFQUFFO0lBQ3RDLE1BQU1XLGFBQWFYLDZDQUFNQSxDQUFDO0lBRTFCRCxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ00sVUFBVU8sT0FBTyxFQUFFO1FBRXhCLE1BQU1DLFNBQVMsQ0FBQ0M7WUFDZCxJQUFJQztZQUVKRCxFQUFFRSxPQUFPLEdBQUc7Z0JBQ1YsbURBQW1EO2dCQUNuREQsY0FBY0QsRUFBRUcsV0FBVyxDQUFDLEtBQUs7Z0JBQ2pDRixZQUFZRyxVQUFVO2dCQUV0QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosWUFBWUssTUFBTSxFQUFFRCxJQUFLO29CQUMzQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSU4sWUFBWU8sS0FBSyxFQUFFRCxJQUFLO3dCQUMxQyxNQUFNRSxRQUFRLENBQUNKLElBQUlKLFlBQVlPLEtBQUssR0FBR0QsQ0FBQUEsSUFBSzt3QkFFNUMsd0NBQXdDO3dCQUN4QyxNQUFNRyxRQUFRO3dCQUNkLE1BQU1DLFFBQVEsTUFBTUMsS0FBS0MsR0FBRyxDQUFDTixJQUFJLE9BQU87d0JBQ3hDLE1BQU1PLFFBQVEsTUFBTUYsS0FBS0csR0FBRyxDQUFDVixJQUFJLE9BQU87d0JBRXhD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RixTQUFTdkcsUUFBUU8sQ0FBQyxHQUFHNkYsU0FBUzdGLENBQUM7WUFDckMsTUFBTWlHLFNBQVN4RyxRQUFRb0QsQ0FBQyxHQUFHZ0QsU0FBU2hELENBQUM7WUFFckMsaUNBQWlDO1lBQ2pDaUQsU0FBUzVGLENBQUMsR0FBRzRGLFNBQVM1RixDQUFDLEdBQUcsTUFBTTZGLFNBQVM7WUFDekNELFNBQVM5RixDQUFDLEdBQUc4RixTQUFTOUYsQ0FBQyxHQUFHLE1BQU1nRyxTQUFTO1lBQ3pDRixTQUFTakQsQ0FBQyxHQUFHaUQsU0FBU2pELENBQUMsR0FBRyxNQUFNb0QsU0FBUztZQUV6QyxpQ0FBaUM7WUFDakMsTUFBTUMsWUFBWUwsU0FBUzNGLENBQUMsR0FBRzRGLFNBQVM1RixDQUFDLEdBQUd5RjtZQUM1QyxNQUFNUSxZQUFZTixTQUFTN0YsQ0FBQyxHQUFHOEYsU0FBUzlGLENBQUMsR0FBRzJGO1lBQzVDLE1BQU1TLFlBQVlQLFNBQVNoRCxDQUFDLEdBQUdpRCxTQUFTakQsQ0FBQyxHQUFHOEM7WUFFNUMsa0NBQWtDO1lBQ2xDLE1BQU1VLFdBQVc5RixLQUFLTSxHQUFHLENBQUMsR0FBR04sS0FBS08sR0FBRyxDQUFDLEdBQUdvRjtZQUN6QyxNQUFNSSxXQUFXL0YsS0FBS00sR0FBRyxDQUFDLEdBQUdOLEtBQUtPLEdBQUcsQ0FBQyxHQUFHcUY7WUFDekMsTUFBTUksV0FBV2hHLEtBQUtNLEdBQUcsQ0FBQyxDQUFDLEdBQUdOLEtBQUtPLEdBQUcsQ0FBQyxHQUFHc0Y7WUFFMUNSLGtCQUFrQnRFLElBQUksQ0FBQztnQkFDckJwQixHQUFHbUc7Z0JBQ0hyRyxHQUFHc0c7Z0JBQ0h6RCxHQUFHMEQ7WUFDTDtRQUNGO1FBRUEsT0FBT1g7SUFDVDtJQUVBLHFCQUFPLDhEQUFDWTtRQUFJQyxLQUFLdkg7Ozs7OztBQUNuQjtHQTlVd0JIO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0hhbmQzRE1vZGVsLnRzeD8zOGY0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgcDUgZnJvbSAncDUnO1xuaW1wb3J0IHsgSGFuZERhdGEgfSBmcm9tICdAL3R5cGVzJztcblxuaW50ZXJmYWNlIEhhbmQzRE1vZGVsUHJvcHMge1xuICBsZWZ0SGFuZDogSGFuZERhdGEgfCBudWxsO1xuICByaWdodEhhbmQ6IEhhbmREYXRhIHwgbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGFuZDNETW9kZWwoeyBsZWZ0SGFuZCwgcmlnaHRIYW5kIH06IEhhbmQzRE1vZGVsUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgcDVJbnN0YW5jZVJlZiA9IHVzZVJlZjxwNSB8IG51bGw+KG51bGwpO1xuICBcbiAgLy8gU21vb3RoaW5nIGFuZCBzdGFiaWxpemF0aW9uIHJlZnNcbiAgY29uc3QgcHJldmlvdXNMZWZ0SGFuZCA9IHVzZVJlZjxhbnlbXSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBwcmV2aW91c1JpZ2h0SGFuZCA9IHVzZVJlZjxhbnlbXSB8IG51bGw+KG51bGwpO1xuICBjb25zdCB2ZWxvY2l0eUxlZnQgPSB1c2VSZWY8YW55W10+KFtdKTtcbiAgY29uc3QgdmVsb2NpdHlSaWdodCA9IHVzZVJlZjxhbnlbXT4oW10pO1xuICBjb25zdCBmcmFtZUNvdW50ID0gdXNlUmVmKDApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2tldGNoID0gKHA6IHA1KSA9PiB7XG4gICAgICBsZXQgaGFuZFRleHR1cmU6IHA1LkltYWdlO1xuXG4gICAgICBwLnByZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHJlYWxpc3RpYyBoYW5kIHRleHR1cmUgcHJvZ3JhbW1hdGljYWxseVxuICAgICAgICBoYW5kVGV4dHVyZSA9IHAuY3JlYXRlSW1hZ2UoMTI4LCAxMjgpO1xuICAgICAgICBoYW5kVGV4dHVyZS5sb2FkUGl4ZWxzKCk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhhbmRUZXh0dXJlLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBoYW5kVGV4dHVyZS53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9ICh5ICogaGFuZFRleHR1cmUud2lkdGggKyB4KSAqIDQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBza2luLWxpa2UgY29sb3Igd2l0aCB2YXJpYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGJhc2VSID0gMjU1O1xuICAgICAgICAgICAgY29uc3QgYmFzZUcgPSAyMDAgKyBNYXRoLnNpbih4ICogMC4xKSAqIDIwO1xuICAgICAgICAgICAgY29uc3QgYmFzZUIgPSAxNTAgKyBNYXRoLmNvcyh5ICogMC4xKSAqIDE1O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgc29tZSB0ZXh0dXJlIHZhcmlhdGlvblxuICAgICAgICAgICAgY29uc3Qgbm9pc2UgPSBNYXRoLnNpbih4ICogMC4wNSkgKiBNYXRoLmNvcyh5ICogMC4wNSkgKiAxMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGFuZFRleHR1cmUucGl4ZWxzW2luZGV4XSA9IE1hdGgubWF4KDIwMCwgTWF0aC5taW4oMjU1LCBiYXNlUiArIG5vaXNlKSk7ICAgICAvLyBSXG4gICAgICAgICAgICBoYW5kVGV4dHVyZS5waXhlbHNbaW5kZXggKyAxXSA9IE1hdGgubWF4KDE4MCwgTWF0aC5taW4oMjIwLCBiYXNlRyArIG5vaXNlKSk7IC8vIEdcbiAgICAgICAgICAgIGhhbmRUZXh0dXJlLnBpeGVsc1tpbmRleCArIDJdID0gTWF0aC5tYXgoMTQwLCBNYXRoLm1pbigxNzAsIGJhc2VCICsgbm9pc2UpKTsgLy8gQlxuICAgICAgICAgICAgaGFuZFRleHR1cmUucGl4ZWxzW2luZGV4ICsgM10gPSAyNTU7IC8vIEFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZFRleHR1cmUudXBkYXRlUGl4ZWxzKCk7XG4gICAgICB9O1xuXG4gICAgICBwLnNldHVwID0gKCkgPT4ge1xuICAgICAgICBwLmNyZWF0ZUNhbnZhcyg4MDAsIDY0MCwgcC5XRUJHTCk7XG4gICAgICAgIHAuZnJhbWVSYXRlKDMwKTsgLy8gTG93ZXIgZnJhbWUgcmF0ZSBmb3Igc3RhYmlsaXR5XG4gICAgICB9O1xuXG4gICAgICBwLmRyYXcgPSAoKSA9PiB7XG4gICAgICAgIHAuY2xlYXIoKTtcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAudHJhbnNsYXRlKDAsIDAsIC0xMDApO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIGxpZ2h0aW5nXG4gICAgICAgIHAuYW1iaWVudExpZ2h0KDYwLCA2MCwgNjApO1xuICAgICAgICBwLmRpcmVjdGlvbmFsTGlnaHQoMjU1LCAyNTUsIDI1NSwgMCwgMCwgLTEpO1xuICAgICAgICBwLnBvaW50TGlnaHQoMjU1LCAyNTUsIDI1NSwgMCwgMCwgMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBcHBseSBzbW9vdGhpbmcgdG8gbGFuZG1hcmtzXG4gICAgICAgIGxldCBzbW9vdGhlZExlZnRMYW5kbWFya3MgPSBudWxsO1xuICAgICAgICBsZXQgc21vb3RoZWRSaWdodExhbmRtYXJrcyA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICBpZiAobGVmdEhhbmQpIHtcbiAgICAgICAgICBzbW9vdGhlZExlZnRMYW5kbWFya3MgPSBzbW9vdGhMYW5kbWFya3MobGVmdEhhbmQubGFuZG1hcmtzLCBwcmV2aW91c0xlZnRIYW5kLmN1cnJlbnQsIHZlbG9jaXR5TGVmdC5jdXJyZW50LCAwLjI1KTtcbiAgICAgICAgICBwcmV2aW91c0xlZnRIYW5kLmN1cnJlbnQgPSBzbW9vdGhlZExlZnRMYW5kbWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyaWdodEhhbmQpIHtcbiAgICAgICAgICBzbW9vdGhlZFJpZ2h0TGFuZG1hcmtzID0gc21vb3RoTGFuZG1hcmtzKHJpZ2h0SGFuZC5sYW5kbWFya3MsIHByZXZpb3VzUmlnaHRIYW5kLmN1cnJlbnQsIHZlbG9jaXR5UmlnaHQuY3VycmVudCwgMC4yNSk7XG4gICAgICAgICAgcHJldmlvdXNSaWdodEhhbmQuY3VycmVudCA9IHNtb290aGVkUmlnaHRMYW5kbWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlbmRlciBsZWZ0IGhhbmQgd2l0aCBzbW9vdGhlZCBsYW5kbWFya3NcbiAgICAgICAgaWYgKHNtb290aGVkTGVmdExhbmRtYXJrcykge1xuICAgICAgICAgIHJlbmRlckhhbmQzRChwLCBzbW9vdGhlZExlZnRMYW5kbWFya3MsIFswLCAyNTUsIDBdLCAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgcmlnaHQgaGFuZCB3aXRoIHNtb290aGVkIGxhbmRtYXJrc1xuICAgICAgICBpZiAoc21vb3RoZWRSaWdodExhbmRtYXJrcykge1xuICAgICAgICAgIHJlbmRlckhhbmQzRChwLCBzbW9vdGhlZFJpZ2h0TGFuZG1hcmtzLCBbMCwgMCwgMjU1XSwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZW5kZXJIYW5kM0QgPSAocDogcDUsIGxhbmRtYXJrczogYW55W10sIGNvbG9yOiBudW1iZXJbXSwgaGFuZFR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIWxhbmRtYXJrcyB8fCBsYW5kbWFya3MubGVuZ3RoIDwgMjEpIHJldHVybjtcblxuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBoYW5kIGNlbnRlciBhbmQgb3JpZW50YXRpb25cbiAgICAgICAgY29uc3QgaGFuZENlbnRlciA9IGNhbGN1bGF0ZUhhbmRDZW50ZXIobGFuZG1hcmtzKTtcbiAgICAgICAgY29uc3QgaGFuZFJvdGF0aW9uID0gY2FsY3VsYXRlSGFuZFJvdGF0aW9uKGxhbmRtYXJrcyk7XG4gICAgICAgIGNvbnN0IGhhbmRTY2FsZSA9IGNhbGN1bGF0ZUhhbmRTY2FsZShsYW5kbWFya3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJhbnNmb3JtIHRvIGhhbmQgcG9zaXRpb24gd2l0aCBzdGFibGUgY29vcmRpbmF0ZSBtYXBwaW5nXG4gICAgICAgIGNvbnN0IHNjcmVlblggPSAtaGFuZENlbnRlci54ICogcC53aWR0aCArIHAud2lkdGggLyAyO1xuICAgICAgICBjb25zdCBzY3JlZW5ZID0gaGFuZENlbnRlci55ICogcC5oZWlnaHQgLSBwLmhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IHNjcmVlblogPSBoYW5kQ2VudGVyLnogKiA1MDsgLy8gUmVkdWNlZCBkZXB0aCBmb3Igc3RhYmlsaXR5XG4gICAgICAgIFxuICAgICAgICBwLnRyYW5zbGF0ZShzY3JlZW5YLCBzY3JlZW5ZLCBzY3JlZW5aKTtcbiAgICAgICAgcC5yb3RhdGVYKGhhbmRSb3RhdGlvbi54KTtcbiAgICAgICAgcC5yb3RhdGVZKGhhbmRSb3RhdGlvbi55KTtcbiAgICAgICAgcC5yb3RhdGVaKGhhbmRSb3RhdGlvbi56KTtcbiAgICAgICAgcC5zY2FsZShoYW5kU2NhbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVuZGVyIHBhbG0gd2l0aCB0ZXh0dXJlXG4gICAgICAgIHJlbmRlclBhbG0ocCwgbGFuZG1hcmtzLCBjb2xvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgZmluZ2VycyB3aXRoIHRleHR1cmVcbiAgICAgICAgcmVuZGVyRmluZ2VycyhwLCBsYW5kbWFya3MsIGNvbG9yKTtcbiAgICAgICAgXG4gICAgICAgIHAucG9wKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjYWxjdWxhdGVIYW5kQ2VudGVyID0gKGxhbmRtYXJrczogYW55W10pID0+IHtcbiAgICAgICAgLy8gVXNlIHdyaXN0IChsYW5kbWFyayAwKSBhcyBjZW50ZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsYW5kbWFya3NbMF0ueCxcbiAgICAgICAgICB5OiBsYW5kbWFya3NbMF0ueSxcbiAgICAgICAgICB6OiBsYW5kbWFya3NbMF0uelxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FsY3VsYXRlSGFuZFJvdGF0aW9uID0gKGxhbmRtYXJrczogYW55W10pID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhbmQgb3JpZW50YXRpb24gYmFzZWQgb24gcGFsbSBsYW5kbWFya3NcbiAgICAgICAgY29uc3Qgd3Jpc3QgPSBsYW5kbWFya3NbMF07XG4gICAgICAgIGNvbnN0IG1pZGRsZUZpbmdlciA9IGxhbmRtYXJrc1sxMl07XG4gICAgICAgIGNvbnN0IGluZGV4RmluZ2VyID0gbGFuZG1hcmtzWzhdO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBhbG0gbm9ybWFsXG4gICAgICAgIGNvbnN0IHBhbG1Ob3JtYWwgPSBwLmNyZWF0ZVZlY3RvcihcbiAgICAgICAgICBtaWRkbGVGaW5nZXIueCAtIHdyaXN0LngsXG4gICAgICAgICAgbWlkZGxlRmluZ2VyLnkgLSB3cmlzdC55LFxuICAgICAgICAgIG1pZGRsZUZpbmdlci56IC0gd3Jpc3QuelxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLmF0YW4yKHBhbG1Ob3JtYWwueSwgcGFsbU5vcm1hbC56KSxcbiAgICAgICAgICB5OiBNYXRoLmF0YW4yKHBhbG1Ob3JtYWwueCwgcGFsbU5vcm1hbC56KSxcbiAgICAgICAgICB6OiBNYXRoLmF0YW4yKHBhbG1Ob3JtYWwueSwgcGFsbU5vcm1hbC54KVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FsY3VsYXRlSGFuZFNjYWxlID0gKGxhbmRtYXJrczogYW55W10pID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhbmQgc2l6ZSBiYXNlZCBvbiBwYWxtIHdpZHRoXG4gICAgICAgIGNvbnN0IHdyaXN0ID0gbGFuZG1hcmtzWzBdO1xuICAgICAgICBjb25zdCBwaW5reSA9IGxhbmRtYXJrc1sxN107XG4gICAgICAgIGNvbnN0IHRodW1iID0gbGFuZG1hcmtzWzRdO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFsbVdpZHRoID0gTWF0aC5hYnMocGlua3kueCAtIHRodW1iLngpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMC41LCBNYXRoLm1pbigyLjAsIHBhbG1XaWR0aCAqIDEwKSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZW5kZXJQYWxtID0gKHA6IHA1LCBsYW5kbWFya3M6IGFueVtdLCBjb2xvcjogbnVtYmVyW10pID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIHBhbG0gdXNpbmcgdGV4dHVyZWQgc3BoZXJlcyBhdCBrZXkgcG9pbnRzXG4gICAgICAgIGNvbnN0IHBhbG1MYW5kbWFya3MgPSBbMCwgNSwgOSwgMTMsIDE3XTsgLy8gV3Jpc3QgYW5kIGZpbmdlciBiYXNlc1xuICAgICAgICBcbiAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgIHAudGV4dHVyZShoYW5kVGV4dHVyZSk7XG4gICAgICAgIHAubm9TdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcGFsbSBjZW50ZXIgd2l0aCB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IHdyaXN0ID0gbGFuZG1hcmtzWzBdO1xuICAgICAgICBjb25zdCBwYWxtQ2VudGVyID0ge1xuICAgICAgICAgIHg6ICh3cmlzdC54IC0gMC41KSAqIDIsXG4gICAgICAgICAgeTogKHdyaXN0LnkgLSAwLjUpICogMixcbiAgICAgICAgICB6OiB3cmlzdC56XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBwLnB1c2goKTtcbiAgICAgICAgcC50cmFuc2xhdGUocGFsbUNlbnRlci54LCBwYWxtQ2VudGVyLnksIHBhbG1DZW50ZXIueik7XG4gICAgICAgIHAuZmlsbCgyNTUsIDIwMCwgMTUwLCAyMDApOyAvLyBTa2luIGNvbG9yXG4gICAgICAgIHAuc3BoZXJlKDAuMDgpO1xuICAgICAgICBwLnBvcCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBwYWxtIGpvaW50cyB3aXRoIHRleHR1cmVcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYWxtTGFuZG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYW5kbWFya3NbcGFsbUxhbmRtYXJrc1tpXV07XG4gICAgICAgICAgY29uc3QgeCA9IChsYW5kbWFyay54IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeSA9IChsYW5kbWFyay55IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgXG4gICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgcC50cmFuc2xhdGUoeCwgeSwgeik7XG4gICAgICAgICAgcC5maWxsKDI1NSwgMjAwLCAxNTAsIDE4MCk7IC8vIFNraW4gY29sb3JcbiAgICAgICAgICBwLnNwaGVyZSgwLjA1KTtcbiAgICAgICAgICBwLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHBhbG0gY29ubmVjdGlvbnMgd2l0aCBza2luIGNvbG9yXG4gICAgICAgIHAubm9GaWxsKCk7XG4gICAgICAgIHAuc3Ryb2tlKDI1NSwgMjAwLCAxNTAsIDEyMCk7XG4gICAgICAgIHAuc3Ryb2tlV2VpZ2h0KDQpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWxtTGFuZG1hcmtzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBsYW5kbWFya3NbcGFsbUxhbmRtYXJrc1tpXV07XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGxhbmRtYXJrc1twYWxtTGFuZG1hcmtzW2kgKyAxXV07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgeDEgPSAoY3VycmVudC54IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeTEgPSAoY3VycmVudC55IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgejEgPSBjdXJyZW50Lno7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgeDIgPSAobmV4dC54IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeTIgPSAobmV4dC55IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgejIgPSBuZXh0Lno7XG4gICAgICAgICAgXG4gICAgICAgICAgcC5saW5lKHgxLCB5MSwgejEsIHgyLCB5MiwgejIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwLnBvcCgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVuZGVyRmluZ2VycyA9IChwOiBwNSwgbGFuZG1hcmtzOiBhbnlbXSwgY29sb3I6IG51bWJlcltdKSA9PiB7XG4gICAgICAgIC8vIEZpbmdlciBsYW5kbWFyayBpbmRpY2VzXG4gICAgICAgIGNvbnN0IGZpbmdlckluZGljZXMgPSBbXG4gICAgICAgICAgWzQsIDMsIDIsIDEsIDBdLCAgICAvLyBUaHVtYlxuICAgICAgICAgIFs4LCA3LCA2LCA1XSwgICAgICAgLy8gSW5kZXhcbiAgICAgICAgICBbMTIsIDExLCAxMCwgOV0sICAgIC8vIE1pZGRsZVxuICAgICAgICAgIFsxNiwgMTUsIDE0LCAxM10sICAgLy8gUmluZ1xuICAgICAgICAgIFsyMCwgMTksIDE4LCAxN10gICAgLy8gUGlua3lcbiAgICAgICAgXTtcblxuICAgICAgICBmaW5nZXJJbmRpY2VzLmZvckVhY2goKGZpbmdlciwgZmluZ2VySW5kZXgpID0+IHtcbiAgICAgICAgICByZW5kZXJGaW5nZXIocCwgbGFuZG1hcmtzLCBmaW5nZXIsIGNvbG9yLCBmaW5nZXJJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVuZGVyRmluZ2VyID0gKHA6IHA1LCBsYW5kbWFya3M6IGFueVtdLCBmaW5nZXJJbmRpY2VzOiBudW1iZXJbXSwgY29sb3I6IG51bWJlcltdLCBmaW5nZXJJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIHAucHVzaCgpO1xuICAgICAgICBwLnRleHR1cmUoaGFuZFRleHR1cmUpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBmaW5nZXIgam9pbnRzIGFzIHRleHR1cmVkIHNwaGVyZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5nZXJJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGFuZG1hcmsgPSBsYW5kbWFya3NbZmluZ2VySW5kaWNlc1tpXV07XG4gICAgICAgICAgY29uc3QgeCA9IChsYW5kbWFyay54IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeSA9IChsYW5kbWFyay55IC0gMC41KSAqIDI7XG4gICAgICAgICAgY29uc3QgeiA9IGxhbmRtYXJrLno7XG4gICAgICAgICAgXG4gICAgICAgICAgcC5wdXNoKCk7XG4gICAgICAgICAgcC50cmFuc2xhdGUoeCwgeSwgeik7XG4gICAgICAgICAgY29uc3Qgam9pbnRTaXplID0gMC4wMjUgKiAoMSAtIGkgKiAwLjEpOyAvLyBTbWFsbGVyIHRvd2FyZHMgdGlwXG4gICAgICAgICAgcC5maWxsKDI1NSwgMjAwLCAxNTAsIDIwMCk7IC8vIFNraW4gY29sb3JcbiAgICAgICAgICBwLnNwaGVyZShqb2ludFNpemUpO1xuICAgICAgICAgIHAucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgZmluZ2VyIGNvbm5lY3Rpb25zIHdpdGggc2tpbiBjb2xvclxuICAgICAgICBwLm5vRmlsbCgpO1xuICAgICAgICBwLnN0cm9rZSgyNTUsIDIwMCwgMTUwLCAxNTApO1xuICAgICAgICBwLnN0cm9rZVdlaWdodCgzKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluZ2VySW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbGFuZG1hcmtzW2ZpbmdlckluZGljZXNbaV1dO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBsYW5kbWFya3NbZmluZ2VySW5kaWNlc1tpICsgMV1dO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgxID0gKGN1cnJlbnQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkxID0gKGN1cnJlbnQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoxID0gY3VycmVudC56O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHgyID0gKG5leHQueCAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHkyID0gKG5leHQueSAtIDAuNSkgKiAyO1xuICAgICAgICAgIGNvbnN0IHoyID0gbmV4dC56O1xuICAgICAgICAgIFxuICAgICAgICAgIHAubGluZSh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcC5wb3AoKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyBwNShza2V0Y2gsIGNhbnZhc1JlZi5jdXJyZW50KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocDVJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHA1SW5zdGFuY2VSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgICAgcDVJbnN0YW5jZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbGVmdEhhbmQsIHJpZ2h0SGFuZF0pO1xuXG4gIC8vIFNtb290aGluZyBmdW5jdGlvbiB3aXRoIHZlbG9jaXR5LWJhc2VkIGludGVycG9sYXRpb25cbiAgY29uc3Qgc21vb3RoTGFuZG1hcmtzID0gKGN1cnJlbnRMYW5kbWFya3M6IGFueVtdLCBwcmV2aW91c0xhbmRtYXJrczogYW55W10gfCBudWxsLCB2ZWxvY2l0aWVzOiBhbnlbXSwgc21vb3RoaW5nRmFjdG9yOiBudW1iZXIgPSAwLjMpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRMYW5kbWFya3MgfHwgY3VycmVudExhbmRtYXJrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcmV2aW91c0xhbmRtYXJrcztcbiAgICB9XG4gICAgXG4gICAgaWYgKCFwcmV2aW91c0xhbmRtYXJrcyB8fCBwcmV2aW91c0xhbmRtYXJrcy5sZW5ndGggIT09IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoKSB7XG4gICAgICAvLyBJbml0aWFsaXplIHZlbG9jaXRpZXNcbiAgICAgIHZlbG9jaXRpZXMubGVuZ3RoID0gY3VycmVudExhbmRtYXJrcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMYW5kbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVsb2NpdGllc1tpXSA9IHsgeDogMCwgeTogMCwgejogMCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRMYW5kbWFya3M7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNtb290aGVkTGFuZG1hcmtzID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGFuZG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gY3VycmVudExhbmRtYXJrc1tpXTtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gcHJldmlvdXNMYW5kbWFya3NbaV07XG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHZlbG9jaXRpZXNbaV07XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB2ZWxvY2l0eSAoY2hhbmdlIGluIHBvc2l0aW9uKVxuICAgICAgY29uc3QgZGVsdGFYID0gY3VycmVudC54IC0gcHJldmlvdXMueDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IGN1cnJlbnQueSAtIHByZXZpb3VzLnk7XG4gICAgICBjb25zdCBkZWx0YVogPSBjdXJyZW50LnogLSBwcmV2aW91cy56O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgd2l0aCBzbW9vdGhpbmdcbiAgICAgIHZlbG9jaXR5LnggPSB2ZWxvY2l0eS54ICogMC44ICsgZGVsdGFYICogMC4yO1xuICAgICAgdmVsb2NpdHkueSA9IHZlbG9jaXR5LnkgKiAwLjggKyBkZWx0YVkgKiAwLjI7XG4gICAgICB2ZWxvY2l0eS56ID0gdmVsb2NpdHkueiAqIDAuOCArIGRlbHRhWiAqIDAuMjtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdmVsb2NpdHktYmFzZWQgc21vb3RoaW5nXG4gICAgICBjb25zdCBzbW9vdGhlZFggPSBwcmV2aW91cy54ICsgdmVsb2NpdHkueCAqIHNtb290aGluZ0ZhY3RvcjtcbiAgICAgIGNvbnN0IHNtb290aGVkWSA9IHByZXZpb3VzLnkgKyB2ZWxvY2l0eS55ICogc21vb3RoaW5nRmFjdG9yO1xuICAgICAgY29uc3Qgc21vb3RoZWRaID0gcHJldmlvdXMueiArIHZlbG9jaXR5LnogKiBzbW9vdGhpbmdGYWN0b3I7XG4gICAgICBcbiAgICAgIC8vIENsYW1wIHRvIHByZXZlbnQgZXh0cmVtZSB2YWx1ZXNcbiAgICAgIGNvbnN0IGNsYW1wZWRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc21vb3RoZWRYKSk7XG4gICAgICBjb25zdCBjbGFtcGVkWSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNtb290aGVkWSkpO1xuICAgICAgY29uc3QgY2xhbXBlZFogPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgc21vb3RoZWRaKSk7XG4gICAgICBcbiAgICAgIHNtb290aGVkTGFuZG1hcmtzLnB1c2goe1xuICAgICAgICB4OiBjbGFtcGVkWCxcbiAgICAgICAgeTogY2xhbXBlZFksXG4gICAgICAgIHo6IGNsYW1wZWRaXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNtb290aGVkTGFuZG1hcmtzO1xuICB9O1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y2FudmFzUmVmfSAvPjtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInA1IiwiSGFuZDNETW9kZWwiLCJsZWZ0SGFuZCIsInJpZ2h0SGFuZCIsImNhbnZhc1JlZiIsInA1SW5zdGFuY2VSZWYiLCJwcmV2aW91c0xlZnRIYW5kIiwicHJldmlvdXNSaWdodEhhbmQiLCJ2ZWxvY2l0eUxlZnQiLCJ2ZWxvY2l0eVJpZ2h0IiwiZnJhbWVDb3VudCIsImN1cnJlbnQiLCJza2V0Y2giLCJwIiwiaGFuZFRleHR1cmUiLCJwcmVsb2FkIiwiY3JlYXRlSW1hZ2UiLCJsb2FkUGl4ZWxzIiwieSIsImhlaWdodCIsIngiLCJ3aWR0aCIsImluZGV4IiwiYmFzZVIiLCJiYXNlRyIsIk1hdGgiLCJzaW4iLCJiYXNlQiIsImNvcyIsIm5vaXNlIiwicGl4ZWxzIiwibWF4IiwibWluIiwidXBkYXRlUGl4ZWxzIiwic2V0dXAiLCJjcmVhdGVDYW52YXMiLCJXRUJHTCIsImZyYW1lUmF0ZSIsImRyYXciLCJjbGVhciIsInB1c2giLCJ0cmFuc2xhdGUiLCJhbWJpZW50TGlnaHQiLCJkaXJlY3Rpb25hbExpZ2h0IiwicG9pbnRMaWdodCIsInNtb290aGVkTGVmdExhbmRtYXJrcyIsInNtb290aGVkUmlnaHRMYW5kbWFya3MiLCJzbW9vdGhMYW5kbWFya3MiLCJsYW5kbWFya3MiLCJyZW5kZXJIYW5kM0QiLCJwb3AiLCJjb2xvciIsImhhbmRUeXBlIiwibGVuZ3RoIiwiaGFuZENlbnRlciIsImNhbGN1bGF0ZUhhbmRDZW50ZXIiLCJoYW5kUm90YXRpb24iLCJjYWxjdWxhdGVIYW5kUm90YXRpb24iLCJoYW5kU2NhbGUiLCJjYWxjdWxhdGVIYW5kU2NhbGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInNjcmVlbloiLCJ6Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2NhbGUiLCJyZW5kZXJQYWxtIiwicmVuZGVyRmluZ2VycyIsIndyaXN0IiwibWlkZGxlRmluZ2VyIiwiaW5kZXhGaW5nZXIiLCJwYWxtTm9ybWFsIiwiY3JlYXRlVmVjdG9yIiwiYXRhbjIiLCJwaW5reSIsInRodW1iIiwicGFsbVdpZHRoIiwiYWJzIiwicGFsbUxhbmRtYXJrcyIsInRleHR1cmUiLCJub1N0cm9rZSIsInBhbG1DZW50ZXIiLCJmaWxsIiwic3BoZXJlIiwiaSIsImxhbmRtYXJrIiwibm9GaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2VpZ2h0IiwibmV4dCIsIngxIiwieTEiLCJ6MSIsIngyIiwieTIiLCJ6MiIsImxpbmUiLCJmaW5nZXJJbmRpY2VzIiwiZm9yRWFjaCIsImZpbmdlciIsImZpbmdlckluZGV4IiwicmVuZGVyRmluZ2VyIiwiam9pbnRTaXplIiwicmVtb3ZlIiwiY3VycmVudExhbmRtYXJrcyIsInByZXZpb3VzTGFuZG1hcmtzIiwidmVsb2NpdGllcyIsInNtb290aGluZ0ZhY3RvciIsInNtb290aGVkTGFuZG1hcmtzIiwicHJldmlvdXMiLCJ2ZWxvY2l0eSIsImRlbHRhWCIsImRlbHRhWSIsImRlbHRhWiIsInNtb290aGVkWCIsInNtb290aGVkWSIsInNtb290aGVkWiIsImNsYW1wZWRYIiwiY2xhbXBlZFkiLCJjbGFtcGVkWiIsImRpdiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Hand3DModel.tsx\n"));

/***/ })

});